// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for mongoatlasreceiver metrics.
type MetricsSettings struct {
	MongodbatlasDbCounts                                  MetricSettings `mapstructure:"mongodbatlas.db.counts"`
	MongodbatlasDbSize                                    MetricSettings `mapstructure:"mongodbatlas.db.size"`
	MongodbatlasDiskPartitionIopsAverage                  MetricSettings `mapstructure:"mongodbatlas.disk.partition.iops.average"`
	MongodbatlasDiskPartitionIopsMax                      MetricSettings `mapstructure:"mongodbatlas.disk.partition.iops.max"`
	MongodbatlasDiskPartitionLatencyAverage               MetricSettings `mapstructure:"mongodbatlas.disk.partition.latency.average"`
	MongodbatlasDiskPartitionLatencyMax                   MetricSettings `mapstructure:"mongodbatlas.disk.partition.latency.max"`
	MongodbatlasDiskPartitionSpaceAverage                 MetricSettings `mapstructure:"mongodbatlas.disk.partition.space.average"`
	MongodbatlasDiskPartitionSpaceMax                     MetricSettings `mapstructure:"mongodbatlas.disk.partition.space.max"`
	MongodbatlasDiskPartitionUsageAverage                 MetricSettings `mapstructure:"mongodbatlas.disk.partition.usage.average"`
	MongodbatlasDiskPartitionUsageMax                     MetricSettings `mapstructure:"mongodbatlas.disk.partition.usage.max"`
	MongodbatlasDiskPartitionUtilizationAverage           MetricSettings `mapstructure:"mongodbatlas.disk.partition.utilization.average"`
	MongodbatlasDiskPartitionUtilizationMax               MetricSettings `mapstructure:"mongodbatlas.disk.partition.utilization.max"`
	MongodbatlasProcessAsserts                            MetricSettings `mapstructure:"mongodbatlas.process.asserts"`
	MongodbatlasProcessBackgroundFlush                    MetricSettings `mapstructure:"mongodbatlas.process.background_flush"`
	MongodbatlasProcessCacheIo                            MetricSettings `mapstructure:"mongodbatlas.process.cache.io"`
	MongodbatlasProcessCacheSize                          MetricSettings `mapstructure:"mongodbatlas.process.cache.size"`
	MongodbatlasProcessConnections                        MetricSettings `mapstructure:"mongodbatlas.process.connections"`
	MongodbatlasProcessCPUChildrenNormalizedUsageAverage  MetricSettings `mapstructure:"mongodbatlas.process.cpu.children.normalized.usage.average"`
	MongodbatlasProcessCPUChildrenNormalizedUsageMax      MetricSettings `mapstructure:"mongodbatlas.process.cpu.children.normalized.usage.max"`
	MongodbatlasProcessCPUChildrenUsageAverage            MetricSettings `mapstructure:"mongodbatlas.process.cpu.children.usage.average"`
	MongodbatlasProcessCPUChildrenUsageMax                MetricSettings `mapstructure:"mongodbatlas.process.cpu.children.usage.max"`
	MongodbatlasProcessCPUNormalizedUsageAverage          MetricSettings `mapstructure:"mongodbatlas.process.cpu.normalized.usage.average"`
	MongodbatlasProcessCPUNormalizedUsageMax              MetricSettings `mapstructure:"mongodbatlas.process.cpu.normalized.usage.max"`
	MongodbatlasProcessCPUUsageAverage                    MetricSettings `mapstructure:"mongodbatlas.process.cpu.usage.average"`
	MongodbatlasProcessCPUUsageMax                        MetricSettings `mapstructure:"mongodbatlas.process.cpu.usage.max"`
	MongodbatlasProcessCursors                            MetricSettings `mapstructure:"mongodbatlas.process.cursors"`
	MongodbatlasProcessDbDocumentRate                     MetricSettings `mapstructure:"mongodbatlas.process.db.document.rate"`
	MongodbatlasProcessDbOperationsRate                   MetricSettings `mapstructure:"mongodbatlas.process.db.operations.rate"`
	MongodbatlasProcessDbOperationsTime                   MetricSettings `mapstructure:"mongodbatlas.process.db.operations.time"`
	MongodbatlasProcessDbQueryExecutorScanned             MetricSettings `mapstructure:"mongodbatlas.process.db.query_executor.scanned"`
	MongodbatlasProcessDbQueryTargetingScannedPerReturned MetricSettings `mapstructure:"mongodbatlas.process.db.query_targeting.scanned_per_returned"`
	MongodbatlasProcessDbStorage                          MetricSettings `mapstructure:"mongodbatlas.process.db.storage"`
	MongodbatlasProcessFtsCPUUsage                        MetricSettings `mapstructure:"mongodbatlas.process.fts.cpu.usage"`
	MongodbatlasProcessGlobalLock                         MetricSettings `mapstructure:"mongodbatlas.process.global_lock"`
	MongodbatlasProcessIndexBtreeMissRatio                MetricSettings `mapstructure:"mongodbatlas.process.index.btree_miss_ratio"`
	MongodbatlasProcessIndexCounters                      MetricSettings `mapstructure:"mongodbatlas.process.index.counters"`
	MongodbatlasProcessJournalingCommits                  MetricSettings `mapstructure:"mongodbatlas.process.journaling.commits"`
	MongodbatlasProcessJournalingDataFiles                MetricSettings `mapstructure:"mongodbatlas.process.journaling.data_files"`
	MongodbatlasProcessJournalingWritten                  MetricSettings `mapstructure:"mongodbatlas.process.journaling.written"`
	MongodbatlasProcessMemoryUsage                        MetricSettings `mapstructure:"mongodbatlas.process.memory.usage"`
	MongodbatlasProcessNetworkIo                          MetricSettings `mapstructure:"mongodbatlas.process.network.io"`
	MongodbatlasProcessNetworkRequests                    MetricSettings `mapstructure:"mongodbatlas.process.network.requests"`
	MongodbatlasProcessOplogRate                          MetricSettings `mapstructure:"mongodbatlas.process.oplog.rate"`
	MongodbatlasProcessOplogTime                          MetricSettings `mapstructure:"mongodbatlas.process.oplog.time"`
	MongodbatlasProcessPageFaults                         MetricSettings `mapstructure:"mongodbatlas.process.page_faults"`
	MongodbatlasProcessRestarts                           MetricSettings `mapstructure:"mongodbatlas.process.restarts"`
	MongodbatlasProcessTickets                            MetricSettings `mapstructure:"mongodbatlas.process.tickets"`
	MongodbatlasSystemCPUNormalizedUsageAverage           MetricSettings `mapstructure:"mongodbatlas.system.cpu.normalized.usage.average"`
	MongodbatlasSystemCPUNormalizedUsageMax               MetricSettings `mapstructure:"mongodbatlas.system.cpu.normalized.usage.max"`
	MongodbatlasSystemCPUUsageAverage                     MetricSettings `mapstructure:"mongodbatlas.system.cpu.usage.average"`
	MongodbatlasSystemCPUUsageMax                         MetricSettings `mapstructure:"mongodbatlas.system.cpu.usage.max"`
	MongodbatlasSystemFtsCPUNormalizedUsage               MetricSettings `mapstructure:"mongodbatlas.system.fts.cpu.normalized.usage"`
	MongodbatlasSystemFtsCPUUsage                         MetricSettings `mapstructure:"mongodbatlas.system.fts.cpu.usage"`
	MongodbatlasSystemFtsDiskUsed                         MetricSettings `mapstructure:"mongodbatlas.system.fts.disk.used"`
	MongodbatlasSystemFtsMemoryUsage                      MetricSettings `mapstructure:"mongodbatlas.system.fts.memory.usage"`
	MongodbatlasSystemMemoryUsageAverage                  MetricSettings `mapstructure:"mongodbatlas.system.memory.usage.average"`
	MongodbatlasSystemMemoryUsageMax                      MetricSettings `mapstructure:"mongodbatlas.system.memory.usage.max"`
	MongodbatlasSystemNetworkIoAverage                    MetricSettings `mapstructure:"mongodbatlas.system.network.io.average"`
	MongodbatlasSystemNetworkIoMax                        MetricSettings `mapstructure:"mongodbatlas.system.network.io.max"`
	MongodbatlasSystemPagingIoAverage                     MetricSettings `mapstructure:"mongodbatlas.system.paging.io.average"`
	MongodbatlasSystemPagingIoMax                         MetricSettings `mapstructure:"mongodbatlas.system.paging.io.max"`
	MongodbatlasSystemPagingUsageAverage                  MetricSettings `mapstructure:"mongodbatlas.system.paging.usage.average"`
	MongodbatlasSystemPagingUsageMax                      MetricSettings `mapstructure:"mongodbatlas.system.paging.usage.max"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		MongodbatlasDbCounts: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDbSize: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionIopsAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionIopsMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionLatencyAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionLatencyMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionSpaceAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionSpaceMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionUtilizationAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasDiskPartitionUtilizationMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessAsserts: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessBackgroundFlush: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCacheIo: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCacheSize: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessConnections: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUChildrenNormalizedUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUChildrenNormalizedUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUChildrenUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUChildrenUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUNormalizedUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUNormalizedUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCPUUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessCursors: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessDbDocumentRate: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessDbOperationsRate: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessDbOperationsTime: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessDbQueryExecutorScanned: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessDbQueryTargetingScannedPerReturned: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessDbStorage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessFtsCPUUsage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessGlobalLock: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessIndexBtreeMissRatio: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessIndexCounters: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessJournalingCommits: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessJournalingDataFiles: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessJournalingWritten: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessMemoryUsage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessNetworkIo: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessNetworkRequests: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessOplogRate: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessOplogTime: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessPageFaults: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessRestarts: MetricSettings{
			Enabled: true,
		},
		MongodbatlasProcessTickets: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemCPUNormalizedUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemCPUNormalizedUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemCPUUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemCPUUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemFtsCPUNormalizedUsage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemFtsCPUUsage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemFtsDiskUsed: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemFtsMemoryUsage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemMemoryUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemMemoryUsageMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemNetworkIoAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemNetworkIoMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemPagingIoAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemPagingIoMax: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemPagingUsageAverage: MetricSettings{
			Enabled: true,
		},
		MongodbatlasSystemPagingUsageMax: MetricSettings{
			Enabled: true,
		},
	}
}

type metricMongodbatlasDbCounts struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.db.counts metric with initial data.
func (m *metricMongodbatlasDbCounts) init() {
	m.data.SetName("mongodbatlas.db.counts")
	m.data.SetDescription("Database feature size")
	m.data.SetUnit("{objects}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDbCounts) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, objectTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.ObjectType, pdata.NewValueString(objectTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDbCounts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDbCounts) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDbCounts(settings MetricSettings) metricMongodbatlasDbCounts {
	m := metricMongodbatlasDbCounts{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDbSize struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.db.size metric with initial data.
func (m *metricMongodbatlasDbSize) init() {
	m.data.SetName("mongodbatlas.db.size")
	m.data.SetDescription("Database feature size")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDbSize) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, objectTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.ObjectType, pdata.NewValueString(objectTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDbSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDbSize) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDbSize(settings MetricSettings) metricMongodbatlasDbSize {
	m := metricMongodbatlasDbSize{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionIopsAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.iops.average metric with initial data.
func (m *metricMongodbatlasDiskPartitionIopsAverage) init() {
	m.data.SetName("mongodbatlas.disk.partition.iops.average")
	m.data.SetDescription("Disk partition iops")
	m.data.SetUnit("{ops}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionIopsAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskDirection, pdata.NewValueString(diskDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionIopsAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionIopsAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionIopsAverage(settings MetricSettings) metricMongodbatlasDiskPartitionIopsAverage {
	m := metricMongodbatlasDiskPartitionIopsAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionIopsMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.iops.max metric with initial data.
func (m *metricMongodbatlasDiskPartitionIopsMax) init() {
	m.data.SetName("mongodbatlas.disk.partition.iops.max")
	m.data.SetDescription("Disk partition iops")
	m.data.SetUnit("{ops}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionIopsMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskDirection, pdata.NewValueString(diskDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionIopsMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionIopsMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionIopsMax(settings MetricSettings) metricMongodbatlasDiskPartitionIopsMax {
	m := metricMongodbatlasDiskPartitionIopsMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionLatencyAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.latency.average metric with initial data.
func (m *metricMongodbatlasDiskPartitionLatencyAverage) init() {
	m.data.SetName("mongodbatlas.disk.partition.latency.average")
	m.data.SetDescription("Disk partition latency")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionLatencyAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskDirection, pdata.NewValueString(diskDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionLatencyAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionLatencyAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionLatencyAverage(settings MetricSettings) metricMongodbatlasDiskPartitionLatencyAverage {
	m := metricMongodbatlasDiskPartitionLatencyAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionLatencyMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.latency.max metric with initial data.
func (m *metricMongodbatlasDiskPartitionLatencyMax) init() {
	m.data.SetName("mongodbatlas.disk.partition.latency.max")
	m.data.SetDescription("Disk partition latency")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionLatencyMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskDirection, pdata.NewValueString(diskDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionLatencyMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionLatencyMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionLatencyMax(settings MetricSettings) metricMongodbatlasDiskPartitionLatencyMax {
	m := metricMongodbatlasDiskPartitionLatencyMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionSpaceAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.space.average metric with initial data.
func (m *metricMongodbatlasDiskPartitionSpaceAverage) init() {
	m.data.SetName("mongodbatlas.disk.partition.space.average")
	m.data.SetDescription("Disk partition space")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionSpaceAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskStatus, pdata.NewValueString(diskStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionSpaceAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionSpaceAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionSpaceAverage(settings MetricSettings) metricMongodbatlasDiskPartitionSpaceAverage {
	m := metricMongodbatlasDiskPartitionSpaceAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionSpaceMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.space.max metric with initial data.
func (m *metricMongodbatlasDiskPartitionSpaceMax) init() {
	m.data.SetName("mongodbatlas.disk.partition.space.max")
	m.data.SetDescription("Disk partition space")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionSpaceMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskStatus, pdata.NewValueString(diskStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionSpaceMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionSpaceMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionSpaceMax(settings MetricSettings) metricMongodbatlasDiskPartitionSpaceMax {
	m := metricMongodbatlasDiskPartitionSpaceMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.usage.average metric with initial data.
func (m *metricMongodbatlasDiskPartitionUsageAverage) init() {
	m.data.SetName("mongodbatlas.disk.partition.usage.average")
	m.data.SetDescription("Disk partition usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskStatus, pdata.NewValueString(diskStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionUsageAverage(settings MetricSettings) metricMongodbatlasDiskPartitionUsageAverage {
	m := metricMongodbatlasDiskPartitionUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.usage.max metric with initial data.
func (m *metricMongodbatlasDiskPartitionUsageMax) init() {
	m.data.SetName("mongodbatlas.disk.partition.usage.max")
	m.data.SetDescription("Disk partition usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskStatus, pdata.NewValueString(diskStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionUsageMax(settings MetricSettings) metricMongodbatlasDiskPartitionUsageMax {
	m := metricMongodbatlasDiskPartitionUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionUtilizationAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.utilization.average metric with initial data.
func (m *metricMongodbatlasDiskPartitionUtilizationAverage) init() {
	m.data.SetName("mongodbatlas.disk.partition.utilization.average")
	m.data.SetDescription("Disk partition utilization (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionUtilizationAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskStatus, pdata.NewValueString(diskStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionUtilizationAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionUtilizationAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionUtilizationAverage(settings MetricSettings) metricMongodbatlasDiskPartitionUtilizationAverage {
	m := metricMongodbatlasDiskPartitionUtilizationAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasDiskPartitionUtilizationMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.disk.partition.utilization.max metric with initial data.
func (m *metricMongodbatlasDiskPartitionUtilizationMax) init() {
	m.data.SetName("mongodbatlas.disk.partition.utilization.max")
	m.data.SetDescription("Disk partition utilization (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasDiskPartitionUtilizationMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DiskStatus, pdata.NewValueString(diskStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasDiskPartitionUtilizationMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasDiskPartitionUtilizationMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasDiskPartitionUtilizationMax(settings MetricSettings) metricMongodbatlasDiskPartitionUtilizationMax {
	m := metricMongodbatlasDiskPartitionUtilizationMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessAsserts struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.asserts metric with initial data.
func (m *metricMongodbatlasProcessAsserts) init() {
	m.data.SetName("mongodbatlas.process.asserts")
	m.data.SetDescription("Number of assertions per second")
	m.data.SetUnit("{assertions}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessAsserts) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, assertTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.AssertType, pdata.NewValueString(assertTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessAsserts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessAsserts) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessAsserts(settings MetricSettings) metricMongodbatlasProcessAsserts {
	m := metricMongodbatlasProcessAsserts{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessBackgroundFlush struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.background_flush metric with initial data.
func (m *metricMongodbatlasProcessBackgroundFlush) init() {
	m.data.SetName("mongodbatlas.process.background_flush")
	m.data.SetDescription("Amount of data flushed in the background")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessBackgroundFlush) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessBackgroundFlush) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessBackgroundFlush) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessBackgroundFlush(settings MetricSettings) metricMongodbatlasProcessBackgroundFlush {
	m := metricMongodbatlasProcessBackgroundFlush{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCacheIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cache.io metric with initial data.
func (m *metricMongodbatlasProcessCacheIo) init() {
	m.data.SetName("mongodbatlas.process.cache.io")
	m.data.SetDescription("Cache throughput (per second)")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCacheIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cacheDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CacheDirection, pdata.NewValueString(cacheDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCacheIo) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCacheIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCacheIo(settings MetricSettings) metricMongodbatlasProcessCacheIo {
	m := metricMongodbatlasProcessCacheIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCacheSize struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cache.size metric with initial data.
func (m *metricMongodbatlasProcessCacheSize) init() {
	m.data.SetName("mongodbatlas.process.cache.size")
	m.data.SetDescription("Cache sizes")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCacheSize) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cacheStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CacheStatus, pdata.NewValueString(cacheStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCacheSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCacheSize) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCacheSize(settings MetricSettings) metricMongodbatlasProcessCacheSize {
	m := metricMongodbatlasProcessCacheSize{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessConnections struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.connections metric with initial data.
func (m *metricMongodbatlasProcessConnections) init() {
	m.data.SetName("mongodbatlas.process.connections")
	m.data.SetDescription("Number of current connections")
	m.data.SetUnit("{connections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricMongodbatlasProcessConnections) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessConnections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessConnections) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessConnections(settings MetricSettings) metricMongodbatlasProcessConnections {
	m := metricMongodbatlasProcessConnections{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.children.normalized.usage.average metric with initial data.
func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage) init() {
	m.data.SetName("mongodbatlas.process.cpu.children.normalized.usage.average")
	m.data.SetDescription("CPU Usage for child processes, normalized to pct")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUChildrenNormalizedUsageAverage(settings MetricSettings) metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage {
	m := metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUChildrenNormalizedUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.children.normalized.usage.max metric with initial data.
func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageMax) init() {
	m.data.SetName("mongodbatlas.process.cpu.children.normalized.usage.max")
	m.data.SetDescription("CPU Usage for child processes, normalized to pct")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUChildrenNormalizedUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUChildrenNormalizedUsageMax(settings MetricSettings) metricMongodbatlasProcessCPUChildrenNormalizedUsageMax {
	m := metricMongodbatlasProcessCPUChildrenNormalizedUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUChildrenUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.children.usage.average metric with initial data.
func (m *metricMongodbatlasProcessCPUChildrenUsageAverage) init() {
	m.data.SetName("mongodbatlas.process.cpu.children.usage.average")
	m.data.SetDescription("CPU Usage for child processes (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUChildrenUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUChildrenUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUChildrenUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUChildrenUsageAverage(settings MetricSettings) metricMongodbatlasProcessCPUChildrenUsageAverage {
	m := metricMongodbatlasProcessCPUChildrenUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUChildrenUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.children.usage.max metric with initial data.
func (m *metricMongodbatlasProcessCPUChildrenUsageMax) init() {
	m.data.SetName("mongodbatlas.process.cpu.children.usage.max")
	m.data.SetDescription("CPU Usage for child processes (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUChildrenUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUChildrenUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUChildrenUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUChildrenUsageMax(settings MetricSettings) metricMongodbatlasProcessCPUChildrenUsageMax {
	m := metricMongodbatlasProcessCPUChildrenUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUNormalizedUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.normalized.usage.average metric with initial data.
func (m *metricMongodbatlasProcessCPUNormalizedUsageAverage) init() {
	m.data.SetName("mongodbatlas.process.cpu.normalized.usage.average")
	m.data.SetDescription("CPU Usage, normalized to pct")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUNormalizedUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUNormalizedUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUNormalizedUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUNormalizedUsageAverage(settings MetricSettings) metricMongodbatlasProcessCPUNormalizedUsageAverage {
	m := metricMongodbatlasProcessCPUNormalizedUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUNormalizedUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.normalized.usage.max metric with initial data.
func (m *metricMongodbatlasProcessCPUNormalizedUsageMax) init() {
	m.data.SetName("mongodbatlas.process.cpu.normalized.usage.max")
	m.data.SetDescription("CPU Usage, normalized to pct")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUNormalizedUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUNormalizedUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUNormalizedUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUNormalizedUsageMax(settings MetricSettings) metricMongodbatlasProcessCPUNormalizedUsageMax {
	m := metricMongodbatlasProcessCPUNormalizedUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.usage.average metric with initial data.
func (m *metricMongodbatlasProcessCPUUsageAverage) init() {
	m.data.SetName("mongodbatlas.process.cpu.usage.average")
	m.data.SetDescription("CPU Usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUUsageAverage(settings MetricSettings) metricMongodbatlasProcessCPUUsageAverage {
	m := metricMongodbatlasProcessCPUUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCPUUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cpu.usage.max metric with initial data.
func (m *metricMongodbatlasProcessCPUUsageMax) init() {
	m.data.SetName("mongodbatlas.process.cpu.usage.max")
	m.data.SetDescription("CPU Usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCPUUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCPUUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCPUUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCPUUsageMax(settings MetricSettings) metricMongodbatlasProcessCPUUsageMax {
	m := metricMongodbatlasProcessCPUUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessCursors struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.cursors metric with initial data.
func (m *metricMongodbatlasProcessCursors) init() {
	m.data.SetName("mongodbatlas.process.cursors")
	m.data.SetDescription("Number of cursors")
	m.data.SetUnit("{cursors}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessCursors) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cursorStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CursorState, pdata.NewValueString(cursorStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessCursors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessCursors) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessCursors(settings MetricSettings) metricMongodbatlasProcessCursors {
	m := metricMongodbatlasProcessCursors{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessDbDocumentRate struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.db.document.rate metric with initial data.
func (m *metricMongodbatlasProcessDbDocumentRate) init() {
	m.data.SetName("mongodbatlas.process.db.document.rate")
	m.data.SetDescription("Document access rates")
	m.data.SetUnit("{documents}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessDbDocumentRate) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, documentStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.DocumentStatus, pdata.NewValueString(documentStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessDbDocumentRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessDbDocumentRate) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessDbDocumentRate(settings MetricSettings) metricMongodbatlasProcessDbDocumentRate {
	m := metricMongodbatlasProcessDbDocumentRate{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessDbOperationsRate struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.db.operations.rate metric with initial data.
func (m *metricMongodbatlasProcessDbOperationsRate) init() {
	m.data.SetName("mongodbatlas.process.db.operations.rate")
	m.data.SetDescription("DB Operation Rates")
	m.data.SetUnit("{operations}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessDbOperationsRate) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, operationAttributeValue string, clusterRoleAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Operation, pdata.NewValueString(operationAttributeValue))
	dp.Attributes().Insert(A.ClusterRole, pdata.NewValueString(clusterRoleAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessDbOperationsRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessDbOperationsRate) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessDbOperationsRate(settings MetricSettings) metricMongodbatlasProcessDbOperationsRate {
	m := metricMongodbatlasProcessDbOperationsRate{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessDbOperationsTime struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.db.operations.time metric with initial data.
func (m *metricMongodbatlasProcessDbOperationsTime) init() {
	m.data.SetName("mongodbatlas.process.db.operations.time")
	m.data.SetDescription("DB Operation Times")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessDbOperationsTime) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, executionTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.ExecutionType, pdata.NewValueString(executionTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessDbOperationsTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessDbOperationsTime) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessDbOperationsTime(settings MetricSettings) metricMongodbatlasProcessDbOperationsTime {
	m := metricMongodbatlasProcessDbOperationsTime{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessDbQueryExecutorScanned struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.db.query_executor.scanned metric with initial data.
func (m *metricMongodbatlasProcessDbQueryExecutorScanned) init() {
	m.data.SetName("mongodbatlas.process.db.query_executor.scanned")
	m.data.SetDescription("Scanned objects")
	m.data.SetUnit("{objects}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessDbQueryExecutorScanned) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, scannedTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.ScannedType, pdata.NewValueString(scannedTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessDbQueryExecutorScanned) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessDbQueryExecutorScanned) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessDbQueryExecutorScanned(settings MetricSettings) metricMongodbatlasProcessDbQueryExecutorScanned {
	m := metricMongodbatlasProcessDbQueryExecutorScanned{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessDbQueryTargetingScannedPerReturned struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.db.query_targeting.scanned_per_returned metric with initial data.
func (m *metricMongodbatlasProcessDbQueryTargetingScannedPerReturned) init() {
	m.data.SetName("mongodbatlas.process.db.query_targeting.scanned_per_returned")
	m.data.SetDescription("Scanned objects per returned")
	m.data.SetUnit("{scanned}/{returned}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessDbQueryTargetingScannedPerReturned) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, scannedTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.ScannedType, pdata.NewValueString(scannedTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessDbQueryTargetingScannedPerReturned) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessDbQueryTargetingScannedPerReturned) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessDbQueryTargetingScannedPerReturned(settings MetricSettings) metricMongodbatlasProcessDbQueryTargetingScannedPerReturned {
	m := metricMongodbatlasProcessDbQueryTargetingScannedPerReturned{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessDbStorage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.db.storage metric with initial data.
func (m *metricMongodbatlasProcessDbStorage) init() {
	m.data.SetName("mongodbatlas.process.db.storage")
	m.data.SetDescription("Storage used by the database")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessDbStorage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, storageStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.StorageStatus, pdata.NewValueString(storageStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessDbStorage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessDbStorage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessDbStorage(settings MetricSettings) metricMongodbatlasProcessDbStorage {
	m := metricMongodbatlasProcessDbStorage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessFtsCPUUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.fts.cpu.usage metric with initial data.
func (m *metricMongodbatlasProcessFtsCPUUsage) init() {
	m.data.SetName("mongodbatlas.process.fts.cpu.usage")
	m.data.SetDescription("Full text search CPU (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessFtsCPUUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessFtsCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessFtsCPUUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessFtsCPUUsage(settings MetricSettings) metricMongodbatlasProcessFtsCPUUsage {
	m := metricMongodbatlasProcessFtsCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessGlobalLock struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.global_lock metric with initial data.
func (m *metricMongodbatlasProcessGlobalLock) init() {
	m.data.SetName("mongodbatlas.process.global_lock")
	m.data.SetDescription("Number and status of locks")
	m.data.SetUnit("{locks}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessGlobalLock) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, globalLockStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.GlobalLockState, pdata.NewValueString(globalLockStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessGlobalLock) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessGlobalLock) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessGlobalLock(settings MetricSettings) metricMongodbatlasProcessGlobalLock {
	m := metricMongodbatlasProcessGlobalLock{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessIndexBtreeMissRatio struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.index.btree_miss_ratio metric with initial data.
func (m *metricMongodbatlasProcessIndexBtreeMissRatio) init() {
	m.data.SetName("mongodbatlas.process.index.btree_miss_ratio")
	m.data.SetDescription("Index miss ratio (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessIndexBtreeMissRatio) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessIndexBtreeMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessIndexBtreeMissRatio) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessIndexBtreeMissRatio(settings MetricSettings) metricMongodbatlasProcessIndexBtreeMissRatio {
	m := metricMongodbatlasProcessIndexBtreeMissRatio{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessIndexCounters struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.index.counters metric with initial data.
func (m *metricMongodbatlasProcessIndexCounters) init() {
	m.data.SetName("mongodbatlas.process.index.counters")
	m.data.SetDescription("Indexes")
	m.data.SetUnit("{indexes}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessIndexCounters) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, btreeCounterTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.BtreeCounterType, pdata.NewValueString(btreeCounterTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessIndexCounters) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessIndexCounters) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessIndexCounters(settings MetricSettings) metricMongodbatlasProcessIndexCounters {
	m := metricMongodbatlasProcessIndexCounters{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessJournalingCommits struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.journaling.commits metric with initial data.
func (m *metricMongodbatlasProcessJournalingCommits) init() {
	m.data.SetName("mongodbatlas.process.journaling.commits")
	m.data.SetDescription("Journaling commits")
	m.data.SetUnit("{commits}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessJournalingCommits) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessJournalingCommits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessJournalingCommits) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessJournalingCommits(settings MetricSettings) metricMongodbatlasProcessJournalingCommits {
	m := metricMongodbatlasProcessJournalingCommits{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessJournalingDataFiles struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.journaling.data_files metric with initial data.
func (m *metricMongodbatlasProcessJournalingDataFiles) init() {
	m.data.SetName("mongodbatlas.process.journaling.data_files")
	m.data.SetDescription("Data file sizes")
	m.data.SetUnit("MiBy")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessJournalingDataFiles) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessJournalingDataFiles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessJournalingDataFiles) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessJournalingDataFiles(settings MetricSettings) metricMongodbatlasProcessJournalingDataFiles {
	m := metricMongodbatlasProcessJournalingDataFiles{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessJournalingWritten struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.journaling.written metric with initial data.
func (m *metricMongodbatlasProcessJournalingWritten) init() {
	m.data.SetName("mongodbatlas.process.journaling.written")
	m.data.SetDescription("Journals written")
	m.data.SetUnit("MiBy")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessJournalingWritten) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessJournalingWritten) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessJournalingWritten) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessJournalingWritten(settings MetricSettings) metricMongodbatlasProcessJournalingWritten {
	m := metricMongodbatlasProcessJournalingWritten{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.memory.usage metric with initial data.
func (m *metricMongodbatlasProcessMemoryUsage) init() {
	m.data.SetName("mongodbatlas.process.memory.usage")
	m.data.SetDescription("Memory Usage")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, memoryStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.MemoryState, pdata.NewValueString(memoryStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessMemoryUsage(settings MetricSettings) metricMongodbatlasProcessMemoryUsage {
	m := metricMongodbatlasProcessMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessNetworkIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.network.io metric with initial data.
func (m *metricMongodbatlasProcessNetworkIo) init() {
	m.data.SetName("mongodbatlas.process.network.io")
	m.data.SetDescription("Network IO")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessNetworkIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessNetworkIo) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessNetworkIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessNetworkIo(settings MetricSettings) metricMongodbatlasProcessNetworkIo {
	m := metricMongodbatlasProcessNetworkIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessNetworkRequests struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.network.requests metric with initial data.
func (m *metricMongodbatlasProcessNetworkRequests) init() {
	m.data.SetName("mongodbatlas.process.network.requests")
	m.data.SetDescription("Network requests")
	m.data.SetUnit("{requests}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricMongodbatlasProcessNetworkRequests) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessNetworkRequests) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessNetworkRequests) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessNetworkRequests(settings MetricSettings) metricMongodbatlasProcessNetworkRequests {
	m := metricMongodbatlasProcessNetworkRequests{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessOplogRate struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.oplog.rate metric with initial data.
func (m *metricMongodbatlasProcessOplogRate) init() {
	m.data.SetName("mongodbatlas.process.oplog.rate")
	m.data.SetDescription("Execution rate by operation")
	m.data.SetUnit("GiBy/h")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessOplogRate) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessOplogRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessOplogRate) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessOplogRate(settings MetricSettings) metricMongodbatlasProcessOplogRate {
	m := metricMongodbatlasProcessOplogRate{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessOplogTime struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.oplog.time metric with initial data.
func (m *metricMongodbatlasProcessOplogTime) init() {
	m.data.SetName("mongodbatlas.process.oplog.time")
	m.data.SetDescription("Execution time by operation")
	m.data.SetUnit("s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessOplogTime) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, oplogTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.OplogType, pdata.NewValueString(oplogTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessOplogTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessOplogTime) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessOplogTime(settings MetricSettings) metricMongodbatlasProcessOplogTime {
	m := metricMongodbatlasProcessOplogTime{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessPageFaults struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.page_faults metric with initial data.
func (m *metricMongodbatlasProcessPageFaults) init() {
	m.data.SetName("mongodbatlas.process.page_faults")
	m.data.SetDescription("Page faults")
	m.data.SetUnit("{faults}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessPageFaults) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, memoryIssueTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.MemoryIssueType, pdata.NewValueString(memoryIssueTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessPageFaults) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessPageFaults(settings MetricSettings) metricMongodbatlasProcessPageFaults {
	m := metricMongodbatlasProcessPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessRestarts struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.restarts metric with initial data.
func (m *metricMongodbatlasProcessRestarts) init() {
	m.data.SetName("mongodbatlas.process.restarts")
	m.data.SetDescription("Restarts in last hour")
	m.data.SetUnit("{restarts}/h")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasProcessRestarts) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessRestarts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessRestarts) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessRestarts(settings MetricSettings) metricMongodbatlasProcessRestarts {
	m := metricMongodbatlasProcessRestarts{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasProcessTickets struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.process.tickets metric with initial data.
func (m *metricMongodbatlasProcessTickets) init() {
	m.data.SetName("mongodbatlas.process.tickets")
	m.data.SetDescription("Tickets")
	m.data.SetUnit("{tickets}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasProcessTickets) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, ticketTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.TicketType, pdata.NewValueString(ticketTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasProcessTickets) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasProcessTickets) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasProcessTickets(settings MetricSettings) metricMongodbatlasProcessTickets {
	m := metricMongodbatlasProcessTickets{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemCPUNormalizedUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.cpu.normalized.usage.average metric with initial data.
func (m *metricMongodbatlasSystemCPUNormalizedUsageAverage) init() {
	m.data.SetName("mongodbatlas.system.cpu.normalized.usage.average")
	m.data.SetDescription("System CPU Normalized to pct")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemCPUNormalizedUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemCPUNormalizedUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemCPUNormalizedUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemCPUNormalizedUsageAverage(settings MetricSettings) metricMongodbatlasSystemCPUNormalizedUsageAverage {
	m := metricMongodbatlasSystemCPUNormalizedUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemCPUNormalizedUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.cpu.normalized.usage.max metric with initial data.
func (m *metricMongodbatlasSystemCPUNormalizedUsageMax) init() {
	m.data.SetName("mongodbatlas.system.cpu.normalized.usage.max")
	m.data.SetDescription("System CPU Normalized to pct")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemCPUNormalizedUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemCPUNormalizedUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemCPUNormalizedUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemCPUNormalizedUsageMax(settings MetricSettings) metricMongodbatlasSystemCPUNormalizedUsageMax {
	m := metricMongodbatlasSystemCPUNormalizedUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemCPUUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.cpu.usage.average metric with initial data.
func (m *metricMongodbatlasSystemCPUUsageAverage) init() {
	m.data.SetName("mongodbatlas.system.cpu.usage.average")
	m.data.SetDescription("System CPU Usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemCPUUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemCPUUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemCPUUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemCPUUsageAverage(settings MetricSettings) metricMongodbatlasSystemCPUUsageAverage {
	m := metricMongodbatlasSystemCPUUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemCPUUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.cpu.usage.max metric with initial data.
func (m *metricMongodbatlasSystemCPUUsageMax) init() {
	m.data.SetName("mongodbatlas.system.cpu.usage.max")
	m.data.SetDescription("System CPU Usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemCPUUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemCPUUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemCPUUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemCPUUsageMax(settings MetricSettings) metricMongodbatlasSystemCPUUsageMax {
	m := metricMongodbatlasSystemCPUUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemFtsCPUNormalizedUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.fts.cpu.normalized.usage metric with initial data.
func (m *metricMongodbatlasSystemFtsCPUNormalizedUsage) init() {
	m.data.SetName("mongodbatlas.system.fts.cpu.normalized.usage")
	m.data.SetDescription("Full text search disk usage (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemFtsCPUNormalizedUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemFtsCPUNormalizedUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemFtsCPUNormalizedUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemFtsCPUNormalizedUsage(settings MetricSettings) metricMongodbatlasSystemFtsCPUNormalizedUsage {
	m := metricMongodbatlasSystemFtsCPUNormalizedUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemFtsCPUUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.fts.cpu.usage metric with initial data.
func (m *metricMongodbatlasSystemFtsCPUUsage) init() {
	m.data.SetName("mongodbatlas.system.fts.cpu.usage")
	m.data.SetDescription("Full-text search (%)")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemFtsCPUUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.CPUState, pdata.NewValueString(cpuStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemFtsCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemFtsCPUUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemFtsCPUUsage(settings MetricSettings) metricMongodbatlasSystemFtsCPUUsage {
	m := metricMongodbatlasSystemFtsCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemFtsDiskUsed struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.fts.disk.used metric with initial data.
func (m *metricMongodbatlasSystemFtsDiskUsed) init() {
	m.data.SetName("mongodbatlas.system.fts.disk.used")
	m.data.SetDescription("Full text search disk usage")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMongodbatlasSystemFtsDiskUsed) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemFtsDiskUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemFtsDiskUsed) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemFtsDiskUsed(settings MetricSettings) metricMongodbatlasSystemFtsDiskUsed {
	m := metricMongodbatlasSystemFtsDiskUsed{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemFtsMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.fts.memory.usage metric with initial data.
func (m *metricMongodbatlasSystemFtsMemoryUsage) init() {
	m.data.SetName("mongodbatlas.system.fts.memory.usage")
	m.data.SetDescription("Full-text search")
	m.data.SetUnit("MiBy")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemFtsMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, memoryStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.MemoryState, pdata.NewValueString(memoryStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemFtsMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemFtsMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemFtsMemoryUsage(settings MetricSettings) metricMongodbatlasSystemFtsMemoryUsage {
	m := metricMongodbatlasSystemFtsMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemMemoryUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.memory.usage.average metric with initial data.
func (m *metricMongodbatlasSystemMemoryUsageAverage) init() {
	m.data.SetName("mongodbatlas.system.memory.usage.average")
	m.data.SetDescription("System Memory Usage")
	m.data.SetUnit("KiBy")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemMemoryUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, memoryStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.MemoryStatus, pdata.NewValueString(memoryStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemMemoryUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemMemoryUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemMemoryUsageAverage(settings MetricSettings) metricMongodbatlasSystemMemoryUsageAverage {
	m := metricMongodbatlasSystemMemoryUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemMemoryUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.memory.usage.max metric with initial data.
func (m *metricMongodbatlasSystemMemoryUsageMax) init() {
	m.data.SetName("mongodbatlas.system.memory.usage.max")
	m.data.SetDescription("System Memory Usage")
	m.data.SetUnit("KiBy")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemMemoryUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, memoryStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.MemoryStatus, pdata.NewValueString(memoryStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemMemoryUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemMemoryUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemMemoryUsageMax(settings MetricSettings) metricMongodbatlasSystemMemoryUsageMax {
	m := metricMongodbatlasSystemMemoryUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemNetworkIoAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.network.io.average metric with initial data.
func (m *metricMongodbatlasSystemNetworkIoAverage) init() {
	m.data.SetName("mongodbatlas.system.network.io.average")
	m.data.SetDescription("System Network IO")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemNetworkIoAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemNetworkIoAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemNetworkIoAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemNetworkIoAverage(settings MetricSettings) metricMongodbatlasSystemNetworkIoAverage {
	m := metricMongodbatlasSystemNetworkIoAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemNetworkIoMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.network.io.max metric with initial data.
func (m *metricMongodbatlasSystemNetworkIoMax) init() {
	m.data.SetName("mongodbatlas.system.network.io.max")
	m.data.SetDescription("System Network IO")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemNetworkIoMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemNetworkIoMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemNetworkIoMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemNetworkIoMax(settings MetricSettings) metricMongodbatlasSystemNetworkIoMax {
	m := metricMongodbatlasSystemNetworkIoMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemPagingIoAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.paging.io.average metric with initial data.
func (m *metricMongodbatlasSystemPagingIoAverage) init() {
	m.data.SetName("mongodbatlas.system.paging.io.average")
	m.data.SetDescription("Swap IO")
	m.data.SetUnit("{pages}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemPagingIoAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemPagingIoAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemPagingIoAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemPagingIoAverage(settings MetricSettings) metricMongodbatlasSystemPagingIoAverage {
	m := metricMongodbatlasSystemPagingIoAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemPagingIoMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.paging.io.max metric with initial data.
func (m *metricMongodbatlasSystemPagingIoMax) init() {
	m.data.SetName("mongodbatlas.system.paging.io.max")
	m.data.SetDescription("Swap IO")
	m.data.SetUnit("{pages}/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemPagingIoMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemPagingIoMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemPagingIoMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemPagingIoMax(settings MetricSettings) metricMongodbatlasSystemPagingIoMax {
	m := metricMongodbatlasSystemPagingIoMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemPagingUsageAverage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.paging.usage.average metric with initial data.
func (m *metricMongodbatlasSystemPagingUsageAverage) init() {
	m.data.SetName("mongodbatlas.system.paging.usage.average")
	m.data.SetDescription("Swap usage")
	m.data.SetUnit("KiBy")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemPagingUsageAverage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemPagingUsageAverage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemPagingUsageAverage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemPagingUsageAverage(settings MetricSettings) metricMongodbatlasSystemPagingUsageAverage {
	m := metricMongodbatlasSystemPagingUsageAverage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMongodbatlasSystemPagingUsageMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills mongodbatlas.system.paging.usage.max metric with initial data.
func (m *metricMongodbatlasSystemPagingUsageMax) init() {
	m.data.SetName("mongodbatlas.system.paging.usage.max")
	m.data.SetDescription("Swap usage")
	m.data.SetUnit("KiBy")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricMongodbatlasSystemPagingUsageMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMongodbatlasSystemPagingUsageMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMongodbatlasSystemPagingUsageMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMongodbatlasSystemPagingUsageMax(settings MetricSettings) metricMongodbatlasSystemPagingUsageMax {
	m := metricMongodbatlasSystemPagingUsageMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                                   pdata.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                                             int             // maximum observed number of metrics per resource.
	resourceCapacity                                            int             // maximum observed number of resource attributes.
	metricsBuffer                                               pdata.Metrics   // accumulates metrics data before emitting.
	metricMongodbatlasDbCounts                                  metricMongodbatlasDbCounts
	metricMongodbatlasDbSize                                    metricMongodbatlasDbSize
	metricMongodbatlasDiskPartitionIopsAverage                  metricMongodbatlasDiskPartitionIopsAverage
	metricMongodbatlasDiskPartitionIopsMax                      metricMongodbatlasDiskPartitionIopsMax
	metricMongodbatlasDiskPartitionLatencyAverage               metricMongodbatlasDiskPartitionLatencyAverage
	metricMongodbatlasDiskPartitionLatencyMax                   metricMongodbatlasDiskPartitionLatencyMax
	metricMongodbatlasDiskPartitionSpaceAverage                 metricMongodbatlasDiskPartitionSpaceAverage
	metricMongodbatlasDiskPartitionSpaceMax                     metricMongodbatlasDiskPartitionSpaceMax
	metricMongodbatlasDiskPartitionUsageAverage                 metricMongodbatlasDiskPartitionUsageAverage
	metricMongodbatlasDiskPartitionUsageMax                     metricMongodbatlasDiskPartitionUsageMax
	metricMongodbatlasDiskPartitionUtilizationAverage           metricMongodbatlasDiskPartitionUtilizationAverage
	metricMongodbatlasDiskPartitionUtilizationMax               metricMongodbatlasDiskPartitionUtilizationMax
	metricMongodbatlasProcessAsserts                            metricMongodbatlasProcessAsserts
	metricMongodbatlasProcessBackgroundFlush                    metricMongodbatlasProcessBackgroundFlush
	metricMongodbatlasProcessCacheIo                            metricMongodbatlasProcessCacheIo
	metricMongodbatlasProcessCacheSize                          metricMongodbatlasProcessCacheSize
	metricMongodbatlasProcessConnections                        metricMongodbatlasProcessConnections
	metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage  metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage
	metricMongodbatlasProcessCPUChildrenNormalizedUsageMax      metricMongodbatlasProcessCPUChildrenNormalizedUsageMax
	metricMongodbatlasProcessCPUChildrenUsageAverage            metricMongodbatlasProcessCPUChildrenUsageAverage
	metricMongodbatlasProcessCPUChildrenUsageMax                metricMongodbatlasProcessCPUChildrenUsageMax
	metricMongodbatlasProcessCPUNormalizedUsageAverage          metricMongodbatlasProcessCPUNormalizedUsageAverage
	metricMongodbatlasProcessCPUNormalizedUsageMax              metricMongodbatlasProcessCPUNormalizedUsageMax
	metricMongodbatlasProcessCPUUsageAverage                    metricMongodbatlasProcessCPUUsageAverage
	metricMongodbatlasProcessCPUUsageMax                        metricMongodbatlasProcessCPUUsageMax
	metricMongodbatlasProcessCursors                            metricMongodbatlasProcessCursors
	metricMongodbatlasProcessDbDocumentRate                     metricMongodbatlasProcessDbDocumentRate
	metricMongodbatlasProcessDbOperationsRate                   metricMongodbatlasProcessDbOperationsRate
	metricMongodbatlasProcessDbOperationsTime                   metricMongodbatlasProcessDbOperationsTime
	metricMongodbatlasProcessDbQueryExecutorScanned             metricMongodbatlasProcessDbQueryExecutorScanned
	metricMongodbatlasProcessDbQueryTargetingScannedPerReturned metricMongodbatlasProcessDbQueryTargetingScannedPerReturned
	metricMongodbatlasProcessDbStorage                          metricMongodbatlasProcessDbStorage
	metricMongodbatlasProcessFtsCPUUsage                        metricMongodbatlasProcessFtsCPUUsage
	metricMongodbatlasProcessGlobalLock                         metricMongodbatlasProcessGlobalLock
	metricMongodbatlasProcessIndexBtreeMissRatio                metricMongodbatlasProcessIndexBtreeMissRatio
	metricMongodbatlasProcessIndexCounters                      metricMongodbatlasProcessIndexCounters
	metricMongodbatlasProcessJournalingCommits                  metricMongodbatlasProcessJournalingCommits
	metricMongodbatlasProcessJournalingDataFiles                metricMongodbatlasProcessJournalingDataFiles
	metricMongodbatlasProcessJournalingWritten                  metricMongodbatlasProcessJournalingWritten
	metricMongodbatlasProcessMemoryUsage                        metricMongodbatlasProcessMemoryUsage
	metricMongodbatlasProcessNetworkIo                          metricMongodbatlasProcessNetworkIo
	metricMongodbatlasProcessNetworkRequests                    metricMongodbatlasProcessNetworkRequests
	metricMongodbatlasProcessOplogRate                          metricMongodbatlasProcessOplogRate
	metricMongodbatlasProcessOplogTime                          metricMongodbatlasProcessOplogTime
	metricMongodbatlasProcessPageFaults                         metricMongodbatlasProcessPageFaults
	metricMongodbatlasProcessRestarts                           metricMongodbatlasProcessRestarts
	metricMongodbatlasProcessTickets                            metricMongodbatlasProcessTickets
	metricMongodbatlasSystemCPUNormalizedUsageAverage           metricMongodbatlasSystemCPUNormalizedUsageAverage
	metricMongodbatlasSystemCPUNormalizedUsageMax               metricMongodbatlasSystemCPUNormalizedUsageMax
	metricMongodbatlasSystemCPUUsageAverage                     metricMongodbatlasSystemCPUUsageAverage
	metricMongodbatlasSystemCPUUsageMax                         metricMongodbatlasSystemCPUUsageMax
	metricMongodbatlasSystemFtsCPUNormalizedUsage               metricMongodbatlasSystemFtsCPUNormalizedUsage
	metricMongodbatlasSystemFtsCPUUsage                         metricMongodbatlasSystemFtsCPUUsage
	metricMongodbatlasSystemFtsDiskUsed                         metricMongodbatlasSystemFtsDiskUsed
	metricMongodbatlasSystemFtsMemoryUsage                      metricMongodbatlasSystemFtsMemoryUsage
	metricMongodbatlasSystemMemoryUsageAverage                  metricMongodbatlasSystemMemoryUsageAverage
	metricMongodbatlasSystemMemoryUsageMax                      metricMongodbatlasSystemMemoryUsageMax
	metricMongodbatlasSystemNetworkIoAverage                    metricMongodbatlasSystemNetworkIoAverage
	metricMongodbatlasSystemNetworkIoMax                        metricMongodbatlasSystemNetworkIoMax
	metricMongodbatlasSystemPagingIoAverage                     metricMongodbatlasSystemPagingIoAverage
	metricMongodbatlasSystemPagingIoMax                         metricMongodbatlasSystemPagingIoMax
	metricMongodbatlasSystemPagingUsageAverage                  metricMongodbatlasSystemPagingUsageAverage
	metricMongodbatlasSystemPagingUsageMax                      metricMongodbatlasSystemPagingUsageMax
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                  pdata.NewTimestampFromTime(time.Now()),
		metricsBuffer:              pdata.NewMetrics(),
		metricMongodbatlasDbCounts: newMetricMongodbatlasDbCounts(settings.MongodbatlasDbCounts),
		metricMongodbatlasDbSize:   newMetricMongodbatlasDbSize(settings.MongodbatlasDbSize),
		metricMongodbatlasDiskPartitionIopsAverage:                  newMetricMongodbatlasDiskPartitionIopsAverage(settings.MongodbatlasDiskPartitionIopsAverage),
		metricMongodbatlasDiskPartitionIopsMax:                      newMetricMongodbatlasDiskPartitionIopsMax(settings.MongodbatlasDiskPartitionIopsMax),
		metricMongodbatlasDiskPartitionLatencyAverage:               newMetricMongodbatlasDiskPartitionLatencyAverage(settings.MongodbatlasDiskPartitionLatencyAverage),
		metricMongodbatlasDiskPartitionLatencyMax:                   newMetricMongodbatlasDiskPartitionLatencyMax(settings.MongodbatlasDiskPartitionLatencyMax),
		metricMongodbatlasDiskPartitionSpaceAverage:                 newMetricMongodbatlasDiskPartitionSpaceAverage(settings.MongodbatlasDiskPartitionSpaceAverage),
		metricMongodbatlasDiskPartitionSpaceMax:                     newMetricMongodbatlasDiskPartitionSpaceMax(settings.MongodbatlasDiskPartitionSpaceMax),
		metricMongodbatlasDiskPartitionUsageAverage:                 newMetricMongodbatlasDiskPartitionUsageAverage(settings.MongodbatlasDiskPartitionUsageAverage),
		metricMongodbatlasDiskPartitionUsageMax:                     newMetricMongodbatlasDiskPartitionUsageMax(settings.MongodbatlasDiskPartitionUsageMax),
		metricMongodbatlasDiskPartitionUtilizationAverage:           newMetricMongodbatlasDiskPartitionUtilizationAverage(settings.MongodbatlasDiskPartitionUtilizationAverage),
		metricMongodbatlasDiskPartitionUtilizationMax:               newMetricMongodbatlasDiskPartitionUtilizationMax(settings.MongodbatlasDiskPartitionUtilizationMax),
		metricMongodbatlasProcessAsserts:                            newMetricMongodbatlasProcessAsserts(settings.MongodbatlasProcessAsserts),
		metricMongodbatlasProcessBackgroundFlush:                    newMetricMongodbatlasProcessBackgroundFlush(settings.MongodbatlasProcessBackgroundFlush),
		metricMongodbatlasProcessCacheIo:                            newMetricMongodbatlasProcessCacheIo(settings.MongodbatlasProcessCacheIo),
		metricMongodbatlasProcessCacheSize:                          newMetricMongodbatlasProcessCacheSize(settings.MongodbatlasProcessCacheSize),
		metricMongodbatlasProcessConnections:                        newMetricMongodbatlasProcessConnections(settings.MongodbatlasProcessConnections),
		metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage:  newMetricMongodbatlasProcessCPUChildrenNormalizedUsageAverage(settings.MongodbatlasProcessCPUChildrenNormalizedUsageAverage),
		metricMongodbatlasProcessCPUChildrenNormalizedUsageMax:      newMetricMongodbatlasProcessCPUChildrenNormalizedUsageMax(settings.MongodbatlasProcessCPUChildrenNormalizedUsageMax),
		metricMongodbatlasProcessCPUChildrenUsageAverage:            newMetricMongodbatlasProcessCPUChildrenUsageAverage(settings.MongodbatlasProcessCPUChildrenUsageAverage),
		metricMongodbatlasProcessCPUChildrenUsageMax:                newMetricMongodbatlasProcessCPUChildrenUsageMax(settings.MongodbatlasProcessCPUChildrenUsageMax),
		metricMongodbatlasProcessCPUNormalizedUsageAverage:          newMetricMongodbatlasProcessCPUNormalizedUsageAverage(settings.MongodbatlasProcessCPUNormalizedUsageAverage),
		metricMongodbatlasProcessCPUNormalizedUsageMax:              newMetricMongodbatlasProcessCPUNormalizedUsageMax(settings.MongodbatlasProcessCPUNormalizedUsageMax),
		metricMongodbatlasProcessCPUUsageAverage:                    newMetricMongodbatlasProcessCPUUsageAverage(settings.MongodbatlasProcessCPUUsageAverage),
		metricMongodbatlasProcessCPUUsageMax:                        newMetricMongodbatlasProcessCPUUsageMax(settings.MongodbatlasProcessCPUUsageMax),
		metricMongodbatlasProcessCursors:                            newMetricMongodbatlasProcessCursors(settings.MongodbatlasProcessCursors),
		metricMongodbatlasProcessDbDocumentRate:                     newMetricMongodbatlasProcessDbDocumentRate(settings.MongodbatlasProcessDbDocumentRate),
		metricMongodbatlasProcessDbOperationsRate:                   newMetricMongodbatlasProcessDbOperationsRate(settings.MongodbatlasProcessDbOperationsRate),
		metricMongodbatlasProcessDbOperationsTime:                   newMetricMongodbatlasProcessDbOperationsTime(settings.MongodbatlasProcessDbOperationsTime),
		metricMongodbatlasProcessDbQueryExecutorScanned:             newMetricMongodbatlasProcessDbQueryExecutorScanned(settings.MongodbatlasProcessDbQueryExecutorScanned),
		metricMongodbatlasProcessDbQueryTargetingScannedPerReturned: newMetricMongodbatlasProcessDbQueryTargetingScannedPerReturned(settings.MongodbatlasProcessDbQueryTargetingScannedPerReturned),
		metricMongodbatlasProcessDbStorage:                          newMetricMongodbatlasProcessDbStorage(settings.MongodbatlasProcessDbStorage),
		metricMongodbatlasProcessFtsCPUUsage:                        newMetricMongodbatlasProcessFtsCPUUsage(settings.MongodbatlasProcessFtsCPUUsage),
		metricMongodbatlasProcessGlobalLock:                         newMetricMongodbatlasProcessGlobalLock(settings.MongodbatlasProcessGlobalLock),
		metricMongodbatlasProcessIndexBtreeMissRatio:                newMetricMongodbatlasProcessIndexBtreeMissRatio(settings.MongodbatlasProcessIndexBtreeMissRatio),
		metricMongodbatlasProcessIndexCounters:                      newMetricMongodbatlasProcessIndexCounters(settings.MongodbatlasProcessIndexCounters),
		metricMongodbatlasProcessJournalingCommits:                  newMetricMongodbatlasProcessJournalingCommits(settings.MongodbatlasProcessJournalingCommits),
		metricMongodbatlasProcessJournalingDataFiles:                newMetricMongodbatlasProcessJournalingDataFiles(settings.MongodbatlasProcessJournalingDataFiles),
		metricMongodbatlasProcessJournalingWritten:                  newMetricMongodbatlasProcessJournalingWritten(settings.MongodbatlasProcessJournalingWritten),
		metricMongodbatlasProcessMemoryUsage:                        newMetricMongodbatlasProcessMemoryUsage(settings.MongodbatlasProcessMemoryUsage),
		metricMongodbatlasProcessNetworkIo:                          newMetricMongodbatlasProcessNetworkIo(settings.MongodbatlasProcessNetworkIo),
		metricMongodbatlasProcessNetworkRequests:                    newMetricMongodbatlasProcessNetworkRequests(settings.MongodbatlasProcessNetworkRequests),
		metricMongodbatlasProcessOplogRate:                          newMetricMongodbatlasProcessOplogRate(settings.MongodbatlasProcessOplogRate),
		metricMongodbatlasProcessOplogTime:                          newMetricMongodbatlasProcessOplogTime(settings.MongodbatlasProcessOplogTime),
		metricMongodbatlasProcessPageFaults:                         newMetricMongodbatlasProcessPageFaults(settings.MongodbatlasProcessPageFaults),
		metricMongodbatlasProcessRestarts:                           newMetricMongodbatlasProcessRestarts(settings.MongodbatlasProcessRestarts),
		metricMongodbatlasProcessTickets:                            newMetricMongodbatlasProcessTickets(settings.MongodbatlasProcessTickets),
		metricMongodbatlasSystemCPUNormalizedUsageAverage:           newMetricMongodbatlasSystemCPUNormalizedUsageAverage(settings.MongodbatlasSystemCPUNormalizedUsageAverage),
		metricMongodbatlasSystemCPUNormalizedUsageMax:               newMetricMongodbatlasSystemCPUNormalizedUsageMax(settings.MongodbatlasSystemCPUNormalizedUsageMax),
		metricMongodbatlasSystemCPUUsageAverage:                     newMetricMongodbatlasSystemCPUUsageAverage(settings.MongodbatlasSystemCPUUsageAverage),
		metricMongodbatlasSystemCPUUsageMax:                         newMetricMongodbatlasSystemCPUUsageMax(settings.MongodbatlasSystemCPUUsageMax),
		metricMongodbatlasSystemFtsCPUNormalizedUsage:               newMetricMongodbatlasSystemFtsCPUNormalizedUsage(settings.MongodbatlasSystemFtsCPUNormalizedUsage),
		metricMongodbatlasSystemFtsCPUUsage:                         newMetricMongodbatlasSystemFtsCPUUsage(settings.MongodbatlasSystemFtsCPUUsage),
		metricMongodbatlasSystemFtsDiskUsed:                         newMetricMongodbatlasSystemFtsDiskUsed(settings.MongodbatlasSystemFtsDiskUsed),
		metricMongodbatlasSystemFtsMemoryUsage:                      newMetricMongodbatlasSystemFtsMemoryUsage(settings.MongodbatlasSystemFtsMemoryUsage),
		metricMongodbatlasSystemMemoryUsageAverage:                  newMetricMongodbatlasSystemMemoryUsageAverage(settings.MongodbatlasSystemMemoryUsageAverage),
		metricMongodbatlasSystemMemoryUsageMax:                      newMetricMongodbatlasSystemMemoryUsageMax(settings.MongodbatlasSystemMemoryUsageMax),
		metricMongodbatlasSystemNetworkIoAverage:                    newMetricMongodbatlasSystemNetworkIoAverage(settings.MongodbatlasSystemNetworkIoAverage),
		metricMongodbatlasSystemNetworkIoMax:                        newMetricMongodbatlasSystemNetworkIoMax(settings.MongodbatlasSystemNetworkIoMax),
		metricMongodbatlasSystemPagingIoAverage:                     newMetricMongodbatlasSystemPagingIoAverage(settings.MongodbatlasSystemPagingIoAverage),
		metricMongodbatlasSystemPagingIoMax:                         newMetricMongodbatlasSystemPagingIoMax(settings.MongodbatlasSystemPagingIoMax),
		metricMongodbatlasSystemPagingUsageAverage:                  newMetricMongodbatlasSystemPagingUsageAverage(settings.MongodbatlasSystemPagingUsageAverage),
		metricMongodbatlasSystemPagingUsageMax:                      newMetricMongodbatlasSystemPagingUsageMax(settings.MongodbatlasSystemPagingUsageMax),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pdata.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceOption applies changes to provided resource.
type ResourceOption func(pdata.Resource)

// WithMongodbAtlasDbName sets provided value as "mongodb_atlas.db.name" attribute for current resource.
func WithMongodbAtlasDbName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.db.name", val)
	}
}

// WithMongodbAtlasDiskPartition sets provided value as "mongodb_atlas.disk.partition" attribute for current resource.
func WithMongodbAtlasDiskPartition(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.disk.partition", val)
	}
}

// WithMongodbAtlasHostName sets provided value as "mongodb_atlas.host.name" attribute for current resource.
func WithMongodbAtlasHostName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.host.name", val)
	}
}

// WithMongodbAtlasOrgName sets provided value as "mongodb_atlas.org_name" attribute for current resource.
func WithMongodbAtlasOrgName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.org_name", val)
	}
}

// WithMongodbAtlasProcessID sets provided value as "mongodb_atlas.process.id" attribute for current resource.
func WithMongodbAtlasProcessID(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.process.id", val)
	}
}

// WithMongodbAtlasProcessPort sets provided value as "mongodb_atlas.process.port" attribute for current resource.
func WithMongodbAtlasProcessPort(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.process.port", val)
	}
}

// WithMongodbAtlasProcessTypeName sets provided value as "mongodb_atlas.process.type_name" attribute for current resource.
func WithMongodbAtlasProcessTypeName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.process.type_name", val)
	}
}

// WithMongodbAtlasProjectID sets provided value as "mongodb_atlas.project.id" attribute for current resource.
func WithMongodbAtlasProjectID(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.project.id", val)
	}
}

// WithMongodbAtlasProjectName sets provided value as "mongodb_atlas.project.name" attribute for current resource.
func WithMongodbAtlasProjectName(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("mongodb_atlas.project.name", val)
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead. Resource attributes should be provided as ResourceOption arguments.
func (mb *MetricsBuilder) EmitForResource(ro ...ResourceOption) {
	rm := pdata.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	for _, op := range ro {
		op(rm.Resource())
	}
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/mongoatlasreceiver")
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricMongodbatlasDbCounts.emit(ils.Metrics())
	mb.metricMongodbatlasDbSize.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionIopsAverage.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionIopsMax.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionLatencyAverage.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionLatencyMax.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionSpaceAverage.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionSpaceMax.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionUtilizationAverage.emit(ils.Metrics())
	mb.metricMongodbatlasDiskPartitionUtilizationMax.emit(ils.Metrics())
	mb.metricMongodbatlasProcessAsserts.emit(ils.Metrics())
	mb.metricMongodbatlasProcessBackgroundFlush.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCacheIo.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCacheSize.emit(ils.Metrics())
	mb.metricMongodbatlasProcessConnections.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUChildrenNormalizedUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUChildrenUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUChildrenUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUNormalizedUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUNormalizedUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCPUUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasProcessCursors.emit(ils.Metrics())
	mb.metricMongodbatlasProcessDbDocumentRate.emit(ils.Metrics())
	mb.metricMongodbatlasProcessDbOperationsRate.emit(ils.Metrics())
	mb.metricMongodbatlasProcessDbOperationsTime.emit(ils.Metrics())
	mb.metricMongodbatlasProcessDbQueryExecutorScanned.emit(ils.Metrics())
	mb.metricMongodbatlasProcessDbQueryTargetingScannedPerReturned.emit(ils.Metrics())
	mb.metricMongodbatlasProcessDbStorage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessFtsCPUUsage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessGlobalLock.emit(ils.Metrics())
	mb.metricMongodbatlasProcessIndexBtreeMissRatio.emit(ils.Metrics())
	mb.metricMongodbatlasProcessIndexCounters.emit(ils.Metrics())
	mb.metricMongodbatlasProcessJournalingCommits.emit(ils.Metrics())
	mb.metricMongodbatlasProcessJournalingDataFiles.emit(ils.Metrics())
	mb.metricMongodbatlasProcessJournalingWritten.emit(ils.Metrics())
	mb.metricMongodbatlasProcessMemoryUsage.emit(ils.Metrics())
	mb.metricMongodbatlasProcessNetworkIo.emit(ils.Metrics())
	mb.metricMongodbatlasProcessNetworkRequests.emit(ils.Metrics())
	mb.metricMongodbatlasProcessOplogRate.emit(ils.Metrics())
	mb.metricMongodbatlasProcessOplogTime.emit(ils.Metrics())
	mb.metricMongodbatlasProcessPageFaults.emit(ils.Metrics())
	mb.metricMongodbatlasProcessRestarts.emit(ils.Metrics())
	mb.metricMongodbatlasProcessTickets.emit(ils.Metrics())
	mb.metricMongodbatlasSystemCPUNormalizedUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemCPUNormalizedUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasSystemCPUUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemCPUUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasSystemFtsCPUNormalizedUsage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemFtsCPUUsage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemFtsDiskUsed.emit(ils.Metrics())
	mb.metricMongodbatlasSystemFtsMemoryUsage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemMemoryUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemMemoryUsageMax.emit(ils.Metrics())
	mb.metricMongodbatlasSystemNetworkIoAverage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemNetworkIoMax.emit(ils.Metrics())
	mb.metricMongodbatlasSystemPagingIoAverage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemPagingIoMax.emit(ils.Metrics())
	mb.metricMongodbatlasSystemPagingUsageAverage.emit(ils.Metrics())
	mb.metricMongodbatlasSystemPagingUsageMax.emit(ils.Metrics())
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(ro ...ResourceOption) pdata.Metrics {
	mb.EmitForResource(ro...)
	metrics := pdata.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordMongodbatlasDbCountsDataPoint adds a data point to mongodbatlas.db.counts metric.
func (mb *MetricsBuilder) RecordMongodbatlasDbCountsDataPoint(ts pdata.Timestamp, val float64, objectTypeAttributeValue string) {
	mb.metricMongodbatlasDbCounts.recordDataPoint(mb.startTime, ts, val, objectTypeAttributeValue)
}

// RecordMongodbatlasDbSizeDataPoint adds a data point to mongodbatlas.db.size metric.
func (mb *MetricsBuilder) RecordMongodbatlasDbSizeDataPoint(ts pdata.Timestamp, val float64, objectTypeAttributeValue string) {
	mb.metricMongodbatlasDbSize.recordDataPoint(mb.startTime, ts, val, objectTypeAttributeValue)
}

// RecordMongodbatlasDiskPartitionIopsAverageDataPoint adds a data point to mongodbatlas.disk.partition.iops.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionIopsAverageDataPoint(ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionIopsAverage.recordDataPoint(mb.startTime, ts, val, diskDirectionAttributeValue)
}

// RecordMongodbatlasDiskPartitionIopsMaxDataPoint adds a data point to mongodbatlas.disk.partition.iops.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionIopsMaxDataPoint(ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionIopsMax.recordDataPoint(mb.startTime, ts, val, diskDirectionAttributeValue)
}

// RecordMongodbatlasDiskPartitionLatencyAverageDataPoint adds a data point to mongodbatlas.disk.partition.latency.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionLatencyAverageDataPoint(ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionLatencyAverage.recordDataPoint(mb.startTime, ts, val, diskDirectionAttributeValue)
}

// RecordMongodbatlasDiskPartitionLatencyMaxDataPoint adds a data point to mongodbatlas.disk.partition.latency.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionLatencyMaxDataPoint(ts pdata.Timestamp, val float64, diskDirectionAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionLatencyMax.recordDataPoint(mb.startTime, ts, val, diskDirectionAttributeValue)
}

// RecordMongodbatlasDiskPartitionSpaceAverageDataPoint adds a data point to mongodbatlas.disk.partition.space.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionSpaceAverageDataPoint(ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionSpaceAverage.recordDataPoint(mb.startTime, ts, val, diskStatusAttributeValue)
}

// RecordMongodbatlasDiskPartitionSpaceMaxDataPoint adds a data point to mongodbatlas.disk.partition.space.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionSpaceMaxDataPoint(ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionSpaceMax.recordDataPoint(mb.startTime, ts, val, diskStatusAttributeValue)
}

// RecordMongodbatlasDiskPartitionUsageAverageDataPoint adds a data point to mongodbatlas.disk.partition.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionUsageAverageDataPoint(ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionUsageAverage.recordDataPoint(mb.startTime, ts, val, diskStatusAttributeValue)
}

// RecordMongodbatlasDiskPartitionUsageMaxDataPoint adds a data point to mongodbatlas.disk.partition.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionUsageMaxDataPoint(ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionUsageMax.recordDataPoint(mb.startTime, ts, val, diskStatusAttributeValue)
}

// RecordMongodbatlasDiskPartitionUtilizationAverageDataPoint adds a data point to mongodbatlas.disk.partition.utilization.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionUtilizationAverageDataPoint(ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionUtilizationAverage.recordDataPoint(mb.startTime, ts, val, diskStatusAttributeValue)
}

// RecordMongodbatlasDiskPartitionUtilizationMaxDataPoint adds a data point to mongodbatlas.disk.partition.utilization.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasDiskPartitionUtilizationMaxDataPoint(ts pdata.Timestamp, val float64, diskStatusAttributeValue string) {
	mb.metricMongodbatlasDiskPartitionUtilizationMax.recordDataPoint(mb.startTime, ts, val, diskStatusAttributeValue)
}

// RecordMongodbatlasProcessAssertsDataPoint adds a data point to mongodbatlas.process.asserts metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessAssertsDataPoint(ts pdata.Timestamp, val float64, assertTypeAttributeValue string) {
	mb.metricMongodbatlasProcessAsserts.recordDataPoint(mb.startTime, ts, val, assertTypeAttributeValue)
}

// RecordMongodbatlasProcessBackgroundFlushDataPoint adds a data point to mongodbatlas.process.background_flush metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessBackgroundFlushDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessBackgroundFlush.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessCacheIoDataPoint adds a data point to mongodbatlas.process.cache.io metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCacheIoDataPoint(ts pdata.Timestamp, val float64, cacheDirectionAttributeValue string) {
	mb.metricMongodbatlasProcessCacheIo.recordDataPoint(mb.startTime, ts, val, cacheDirectionAttributeValue)
}

// RecordMongodbatlasProcessCacheSizeDataPoint adds a data point to mongodbatlas.process.cache.size metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCacheSizeDataPoint(ts pdata.Timestamp, val float64, cacheStatusAttributeValue string) {
	mb.metricMongodbatlasProcessCacheSize.recordDataPoint(mb.startTime, ts, val, cacheStatusAttributeValue)
}

// RecordMongodbatlasProcessConnectionsDataPoint adds a data point to mongodbatlas.process.connections metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessConnectionsDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessCPUChildrenNormalizedUsageAverageDataPoint adds a data point to mongodbatlas.process.cpu.children.normalized.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUChildrenNormalizedUsageAverageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUChildrenNormalizedUsageAverage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUChildrenNormalizedUsageMaxDataPoint adds a data point to mongodbatlas.process.cpu.children.normalized.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUChildrenNormalizedUsageMaxDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUChildrenNormalizedUsageMax.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUChildrenUsageAverageDataPoint adds a data point to mongodbatlas.process.cpu.children.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUChildrenUsageAverageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUChildrenUsageAverage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUChildrenUsageMaxDataPoint adds a data point to mongodbatlas.process.cpu.children.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUChildrenUsageMaxDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUChildrenUsageMax.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUNormalizedUsageAverageDataPoint adds a data point to mongodbatlas.process.cpu.normalized.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUNormalizedUsageAverageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUNormalizedUsageAverage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUNormalizedUsageMaxDataPoint adds a data point to mongodbatlas.process.cpu.normalized.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUNormalizedUsageMaxDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUNormalizedUsageMax.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUUsageAverageDataPoint adds a data point to mongodbatlas.process.cpu.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUUsageAverageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUUsageAverage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCPUUsageMaxDataPoint adds a data point to mongodbatlas.process.cpu.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCPUUsageMaxDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessCPUUsageMax.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessCursorsDataPoint adds a data point to mongodbatlas.process.cursors metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessCursorsDataPoint(ts pdata.Timestamp, val float64, cursorStateAttributeValue string) {
	mb.metricMongodbatlasProcessCursors.recordDataPoint(mb.startTime, ts, val, cursorStateAttributeValue)
}

// RecordMongodbatlasProcessDbDocumentRateDataPoint adds a data point to mongodbatlas.process.db.document.rate metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessDbDocumentRateDataPoint(ts pdata.Timestamp, val float64, documentStatusAttributeValue string) {
	mb.metricMongodbatlasProcessDbDocumentRate.recordDataPoint(mb.startTime, ts, val, documentStatusAttributeValue)
}

// RecordMongodbatlasProcessDbOperationsRateDataPoint adds a data point to mongodbatlas.process.db.operations.rate metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessDbOperationsRateDataPoint(ts pdata.Timestamp, val float64, operationAttributeValue string, clusterRoleAttributeValue string) {
	mb.metricMongodbatlasProcessDbOperationsRate.recordDataPoint(mb.startTime, ts, val, operationAttributeValue, clusterRoleAttributeValue)
}

// RecordMongodbatlasProcessDbOperationsTimeDataPoint adds a data point to mongodbatlas.process.db.operations.time metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessDbOperationsTimeDataPoint(ts pdata.Timestamp, val float64, executionTypeAttributeValue string) {
	mb.metricMongodbatlasProcessDbOperationsTime.recordDataPoint(mb.startTime, ts, val, executionTypeAttributeValue)
}

// RecordMongodbatlasProcessDbQueryExecutorScannedDataPoint adds a data point to mongodbatlas.process.db.query_executor.scanned metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessDbQueryExecutorScannedDataPoint(ts pdata.Timestamp, val float64, scannedTypeAttributeValue string) {
	mb.metricMongodbatlasProcessDbQueryExecutorScanned.recordDataPoint(mb.startTime, ts, val, scannedTypeAttributeValue)
}

// RecordMongodbatlasProcessDbQueryTargetingScannedPerReturnedDataPoint adds a data point to mongodbatlas.process.db.query_targeting.scanned_per_returned metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessDbQueryTargetingScannedPerReturnedDataPoint(ts pdata.Timestamp, val float64, scannedTypeAttributeValue string) {
	mb.metricMongodbatlasProcessDbQueryTargetingScannedPerReturned.recordDataPoint(mb.startTime, ts, val, scannedTypeAttributeValue)
}

// RecordMongodbatlasProcessDbStorageDataPoint adds a data point to mongodbatlas.process.db.storage metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessDbStorageDataPoint(ts pdata.Timestamp, val float64, storageStatusAttributeValue string) {
	mb.metricMongodbatlasProcessDbStorage.recordDataPoint(mb.startTime, ts, val, storageStatusAttributeValue)
}

// RecordMongodbatlasProcessFtsCPUUsageDataPoint adds a data point to mongodbatlas.process.fts.cpu.usage metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessFtsCPUUsageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasProcessFtsCPUUsage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasProcessGlobalLockDataPoint adds a data point to mongodbatlas.process.global_lock metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessGlobalLockDataPoint(ts pdata.Timestamp, val float64, globalLockStateAttributeValue string) {
	mb.metricMongodbatlasProcessGlobalLock.recordDataPoint(mb.startTime, ts, val, globalLockStateAttributeValue)
}

// RecordMongodbatlasProcessIndexBtreeMissRatioDataPoint adds a data point to mongodbatlas.process.index.btree_miss_ratio metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessIndexBtreeMissRatioDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessIndexBtreeMissRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessIndexCountersDataPoint adds a data point to mongodbatlas.process.index.counters metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessIndexCountersDataPoint(ts pdata.Timestamp, val float64, btreeCounterTypeAttributeValue string) {
	mb.metricMongodbatlasProcessIndexCounters.recordDataPoint(mb.startTime, ts, val, btreeCounterTypeAttributeValue)
}

// RecordMongodbatlasProcessJournalingCommitsDataPoint adds a data point to mongodbatlas.process.journaling.commits metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessJournalingCommitsDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessJournalingCommits.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessJournalingDataFilesDataPoint adds a data point to mongodbatlas.process.journaling.data_files metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessJournalingDataFilesDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessJournalingDataFiles.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessJournalingWrittenDataPoint adds a data point to mongodbatlas.process.journaling.written metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessJournalingWrittenDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessJournalingWritten.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessMemoryUsageDataPoint adds a data point to mongodbatlas.process.memory.usage metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessMemoryUsageDataPoint(ts pdata.Timestamp, val float64, memoryStateAttributeValue string) {
	mb.metricMongodbatlasProcessMemoryUsage.recordDataPoint(mb.startTime, ts, val, memoryStateAttributeValue)
}

// RecordMongodbatlasProcessNetworkIoDataPoint adds a data point to mongodbatlas.process.network.io metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessNetworkIoDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasProcessNetworkIo.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordMongodbatlasProcessNetworkRequestsDataPoint adds a data point to mongodbatlas.process.network.requests metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessNetworkRequestsDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessNetworkRequests.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessOplogRateDataPoint adds a data point to mongodbatlas.process.oplog.rate metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessOplogRateDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessOplogRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessOplogTimeDataPoint adds a data point to mongodbatlas.process.oplog.time metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessOplogTimeDataPoint(ts pdata.Timestamp, val float64, oplogTypeAttributeValue string) {
	mb.metricMongodbatlasProcessOplogTime.recordDataPoint(mb.startTime, ts, val, oplogTypeAttributeValue)
}

// RecordMongodbatlasProcessPageFaultsDataPoint adds a data point to mongodbatlas.process.page_faults metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessPageFaultsDataPoint(ts pdata.Timestamp, val float64, memoryIssueTypeAttributeValue string) {
	mb.metricMongodbatlasProcessPageFaults.recordDataPoint(mb.startTime, ts, val, memoryIssueTypeAttributeValue)
}

// RecordMongodbatlasProcessRestartsDataPoint adds a data point to mongodbatlas.process.restarts metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessRestartsDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasProcessRestarts.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasProcessTicketsDataPoint adds a data point to mongodbatlas.process.tickets metric.
func (mb *MetricsBuilder) RecordMongodbatlasProcessTicketsDataPoint(ts pdata.Timestamp, val float64, ticketTypeAttributeValue string) {
	mb.metricMongodbatlasProcessTickets.recordDataPoint(mb.startTime, ts, val, ticketTypeAttributeValue)
}

// RecordMongodbatlasSystemCPUNormalizedUsageAverageDataPoint adds a data point to mongodbatlas.system.cpu.normalized.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemCPUNormalizedUsageAverageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasSystemCPUNormalizedUsageAverage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasSystemCPUNormalizedUsageMaxDataPoint adds a data point to mongodbatlas.system.cpu.normalized.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemCPUNormalizedUsageMaxDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasSystemCPUNormalizedUsageMax.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasSystemCPUUsageAverageDataPoint adds a data point to mongodbatlas.system.cpu.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemCPUUsageAverageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasSystemCPUUsageAverage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasSystemCPUUsageMaxDataPoint adds a data point to mongodbatlas.system.cpu.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemCPUUsageMaxDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasSystemCPUUsageMax.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasSystemFtsCPUNormalizedUsageDataPoint adds a data point to mongodbatlas.system.fts.cpu.normalized.usage metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemFtsCPUNormalizedUsageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasSystemFtsCPUNormalizedUsage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasSystemFtsCPUUsageDataPoint adds a data point to mongodbatlas.system.fts.cpu.usage metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemFtsCPUUsageDataPoint(ts pdata.Timestamp, val float64, cpuStateAttributeValue string) {
	mb.metricMongodbatlasSystemFtsCPUUsage.recordDataPoint(mb.startTime, ts, val, cpuStateAttributeValue)
}

// RecordMongodbatlasSystemFtsDiskUsedDataPoint adds a data point to mongodbatlas.system.fts.disk.used metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemFtsDiskUsedDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricMongodbatlasSystemFtsDiskUsed.recordDataPoint(mb.startTime, ts, val)
}

// RecordMongodbatlasSystemFtsMemoryUsageDataPoint adds a data point to mongodbatlas.system.fts.memory.usage metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemFtsMemoryUsageDataPoint(ts pdata.Timestamp, val float64, memoryStateAttributeValue string) {
	mb.metricMongodbatlasSystemFtsMemoryUsage.recordDataPoint(mb.startTime, ts, val, memoryStateAttributeValue)
}

// RecordMongodbatlasSystemMemoryUsageAverageDataPoint adds a data point to mongodbatlas.system.memory.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemMemoryUsageAverageDataPoint(ts pdata.Timestamp, val float64, memoryStatusAttributeValue string) {
	mb.metricMongodbatlasSystemMemoryUsageAverage.recordDataPoint(mb.startTime, ts, val, memoryStatusAttributeValue)
}

// RecordMongodbatlasSystemMemoryUsageMaxDataPoint adds a data point to mongodbatlas.system.memory.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemMemoryUsageMaxDataPoint(ts pdata.Timestamp, val float64, memoryStatusAttributeValue string) {
	mb.metricMongodbatlasSystemMemoryUsageMax.recordDataPoint(mb.startTime, ts, val, memoryStatusAttributeValue)
}

// RecordMongodbatlasSystemNetworkIoAverageDataPoint adds a data point to mongodbatlas.system.network.io.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemNetworkIoAverageDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasSystemNetworkIoAverage.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordMongodbatlasSystemNetworkIoMaxDataPoint adds a data point to mongodbatlas.system.network.io.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemNetworkIoMaxDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasSystemNetworkIoMax.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordMongodbatlasSystemPagingIoAverageDataPoint adds a data point to mongodbatlas.system.paging.io.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemPagingIoAverageDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasSystemPagingIoAverage.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordMongodbatlasSystemPagingIoMaxDataPoint adds a data point to mongodbatlas.system.paging.io.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemPagingIoMaxDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasSystemPagingIoMax.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordMongodbatlasSystemPagingUsageAverageDataPoint adds a data point to mongodbatlas.system.paging.usage.average metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemPagingUsageAverageDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasSystemPagingUsageAverage.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordMongodbatlasSystemPagingUsageMaxDataPoint adds a data point to mongodbatlas.system.paging.usage.max metric.
func (mb *MetricsBuilder) RecordMongodbatlasSystemPagingUsageMaxDataPoint(ts pdata.Timestamp, val float64, directionAttributeValue string) {
	mb.metricMongodbatlasSystemPagingUsageMax.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// AssertType (MongoDB assertion type)
	AssertType string
	// BtreeCounterType (Database index effectiveness)
	BtreeCounterType string
	// CacheDirection (Whether read into or written from)
	CacheDirection string
	// CacheStatus (Cache status)
	CacheStatus string
	// ClusterRole (Whether process is acting as replica or primary)
	ClusterRole string
	// CPUState (CPU state)
	CPUState string
	// CursorState (Whether cursor is open or timed out)
	CursorState string
	// Direction (Network traffic direction)
	Direction string
	// DiskDirection (Measurement type for disk operation)
	DiskDirection string
	// DiskStatus (Disk measurement type)
	DiskStatus string
	// DocumentStatus (Status of documents in the database)
	DocumentStatus string
	// ExecutionType (Type of command)
	ExecutionType string
	// GlobalLockState (Which queue is locked)
	GlobalLockState string
	// MemoryIssueType (Type of memory issue encountered)
	MemoryIssueType string
	// MemoryState (Memory usage type)
	MemoryState string
	// MemoryStatus (Memory measurement type)
	MemoryStatus string
	// ObjectType (MongoDB object type)
	ObjectType string
	// Operation (Type of database operation)
	Operation string
	// OplogType (Oplog type)
	OplogType string
	// ScannedType (Objects or indexes scanned during query)
	ScannedType string
	// StorageStatus (Views on database size)
	StorageStatus string
	// TicketType (Type of ticket available)
	TicketType string
}{
	"assert_type",
	"btree_counter_type",
	"cache_direction",
	"cache_status",
	"cluster_role",
	"cpu_state",
	"cursor_state",
	"direction",
	"disk_direction",
	"disk_status",
	"document_status",
	"execution_type",
	"global_lock_state",
	"memory_issue_type",
	"memory_state",
	"memory_status",
	"object_type",
	"operation",
	"oplog_type",
	"scanned_type",
	"storage_status",
	"ticket_type",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeAssertType are the possible values that the attribute "assert_type" can have.
var AttributeAssertType = struct {
	Regular string
	Warning string
	Msg     string
	User    string
}{
	"regular",
	"warning",
	"msg",
	"user",
}

// AttributeBtreeCounterType are the possible values that the attribute "btree_counter_type" can have.
var AttributeBtreeCounterType = struct {
	Accesses string
	Hits     string
	Misses   string
}{
	"accesses",
	"hits",
	"misses",
}

// AttributeCacheDirection are the possible values that the attribute "cache_direction" can have.
var AttributeCacheDirection = struct {
	ReadInto    string
	WrittenFrom string
}{
	"read_into",
	"written_from",
}

// AttributeCacheStatus are the possible values that the attribute "cache_status" can have.
var AttributeCacheStatus = struct {
	Dirty string
	Used  string
}{
	"dirty",
	"used",
}

// AttributeClusterRole are the possible values that the attribute "cluster_role" can have.
var AttributeClusterRole = struct {
	Primary string
	Replica string
}{
	"primary",
	"replica",
}

// AttributeCPUState are the possible values that the attribute "cpu_state" can have.
var AttributeCPUState = struct {
	Kernel  string
	User    string
	Nice    string
	Iowait  string
	Irq     string
	Softirq string
	Guest   string
	Steal   string
}{
	"kernel",
	"user",
	"nice",
	"iowait",
	"irq",
	"softirq",
	"guest",
	"steal",
}

// AttributeCursorState are the possible values that the attribute "cursor_state" can have.
var AttributeCursorState = struct {
	TimedOut string
	Open     string
}{
	"timed_out",
	"open",
}

// AttributeDirection are the possible values that the attribute "direction" can have.
var AttributeDirection = struct {
	Receive  string
	Transmit string
}{
	"receive",
	"transmit",
}

// AttributeDiskDirection are the possible values that the attribute "disk_direction" can have.
var AttributeDiskDirection = struct {
	Read  string
	Write string
	Total string
}{
	"read",
	"write",
	"total",
}

// AttributeDiskStatus are the possible values that the attribute "disk_status" can have.
var AttributeDiskStatus = struct {
	Free string
	Used string
}{
	"free",
	"used",
}

// AttributeDocumentStatus are the possible values that the attribute "document_status" can have.
var AttributeDocumentStatus = struct {
	Returned string
	Inserted string
	Updated  string
	Deleted  string
}{
	"returned",
	"inserted",
	"updated",
	"deleted",
}

// AttributeExecutionType are the possible values that the attribute "execution_type" can have.
var AttributeExecutionType = struct {
	Reads    string
	Writes   string
	Commands string
}{
	"reads",
	"writes",
	"commands",
}

// AttributeGlobalLockState are the possible values that the attribute "global_lock_state" can have.
var AttributeGlobalLockState = struct {
	CurrentQueueTotal   string
	CurrentQueueReaders string
	CurrentQueueWriters string
}{
	"current_queue_total",
	"current_queue_readers",
	"current_queue_writers",
}

// AttributeMemoryIssueType are the possible values that the attribute "memory_issue_type" can have.
var AttributeMemoryIssueType = struct {
	ExtraInfo                 string
	GlobalAccessesNotInMemory string
	ExceptionsThrown          string
}{
	"extra_info",
	"global_accesses_not_in_memory",
	"exceptions_thrown",
}

// AttributeMemoryState are the possible values that the attribute "memory_state" can have.
var AttributeMemoryState = struct {
	Resident string
	Virtual  string
	Mapped   string
	Computed string
	Shared   string
	Free     string
	Used     string
}{
	"resident",
	"virtual",
	"mapped",
	"computed",
	"shared",
	"free",
	"used",
}

// AttributeMemoryStatus are the possible values that the attribute "memory_status" can have.
var AttributeMemoryStatus = struct {
	Available string
	Buffers   string
	Cached    string
	Free      string
	Shared    string
	Used      string
}{
	"available",
	"buffers",
	"cached",
	"free",
	"shared",
	"used",
}

// AttributeObjectType are the possible values that the attribute "object_type" can have.
var AttributeObjectType = struct {
	Collection string
	Index      string
	Extent     string
	Object     string
	View       string
	Storage    string
	Data       string
}{
	"collection",
	"index",
	"extent",
	"object",
	"view",
	"storage",
	"data",
}

// AttributeOperation are the possible values that the attribute "operation" can have.
var AttributeOperation = struct {
	Cmd          string
	Query        string
	Update       string
	Delete       string
	Getmore      string
	Insert       string
	ScanAndOrder string
}{
	"cmd",
	"query",
	"update",
	"delete",
	"getmore",
	"insert",
	"scan_and_order",
}

// AttributeOplogType are the possible values that the attribute "oplog_type" can have.
var AttributeOplogType = struct {
	SlaveLagMasterTime string
	MasterTime         string
	MasterLagTimeDiff  string
}{
	"slave_lag_master_time",
	"master_time",
	"master_lag_time_diff",
}

// AttributeScannedType are the possible values that the attribute "scanned_type" can have.
var AttributeScannedType = struct {
	IndexItems string
	Objects    string
}{
	"index_items",
	"objects",
}

// AttributeStorageStatus are the possible values that the attribute "storage_status" can have.
var AttributeStorageStatus = struct {
	Total            string
	DataSize         string
	IndexSize        string
	DataSizeWoSystem string
}{
	"total",
	"data_size",
	"index_size",
	"data_size_wo_system",
}

// AttributeTicketType are the possible values that the attribute "ticket_type" can have.
var AttributeTicketType = struct {
	AvailableReads  string
	AvailableWrites string
}{
	"available_reads",
	"available_writes",
}
