// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for zookeeperreceiver metrics.
type MetricsSettings struct {
	ZookeeperConnectionActive            MetricSettings `mapstructure:"zookeeper.connection.active"`
	ZookeeperDataTreeEphemeralNodeCount  MetricSettings `mapstructure:"zookeeper.data_tree.ephemeral_node.count"`
	ZookeeperDataTreeSize                MetricSettings `mapstructure:"zookeeper.data_tree.size"`
	ZookeeperFileDescriptorLimit         MetricSettings `mapstructure:"zookeeper.file_descriptor.limit"`
	ZookeeperFileDescriptorOpen          MetricSettings `mapstructure:"zookeeper.file_descriptor.open"`
	ZookeeperFollowerCount               MetricSettings `mapstructure:"zookeeper.follower.count"`
	ZookeeperFsyncExceededThresholdCount MetricSettings `mapstructure:"zookeeper.fsync.exceeded_threshold.count"`
	ZookeeperLatencyAvg                  MetricSettings `mapstructure:"zookeeper.latency.avg"`
	ZookeeperLatencyMax                  MetricSettings `mapstructure:"zookeeper.latency.max"`
	ZookeeperLatencyMin                  MetricSettings `mapstructure:"zookeeper.latency.min"`
	ZookeeperPacketCount                 MetricSettings `mapstructure:"zookeeper.packet.count"`
	ZookeeperRequestActive               MetricSettings `mapstructure:"zookeeper.request.active"`
	ZookeeperSyncPending                 MetricSettings `mapstructure:"zookeeper.sync.pending"`
	ZookeeperWatchCount                  MetricSettings `mapstructure:"zookeeper.watch.count"`
	ZookeeperZnodeCount                  MetricSettings `mapstructure:"zookeeper.znode.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ZookeeperConnectionActive: MetricSettings{
			Enabled: true,
		},
		ZookeeperDataTreeEphemeralNodeCount: MetricSettings{
			Enabled: true,
		},
		ZookeeperDataTreeSize: MetricSettings{
			Enabled: true,
		},
		ZookeeperFileDescriptorLimit: MetricSettings{
			Enabled: true,
		},
		ZookeeperFileDescriptorOpen: MetricSettings{
			Enabled: true,
		},
		ZookeeperFollowerCount: MetricSettings{
			Enabled: true,
		},
		ZookeeperFsyncExceededThresholdCount: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyAvg: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyMax: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyMin: MetricSettings{
			Enabled: true,
		},
		ZookeeperPacketCount: MetricSettings{
			Enabled: true,
		},
		ZookeeperRequestActive: MetricSettings{
			Enabled: true,
		},
		ZookeeperSyncPending: MetricSettings{
			Enabled: true,
		},
		ZookeeperWatchCount: MetricSettings{
			Enabled: true,
		},
		ZookeeperZnodeCount: MetricSettings{
			Enabled: true,
		},
	}
}

type metricZookeeperConnectionActive struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.connection.active metric with initial data.
func (m *metricZookeeperConnectionActive) init() {
	m.data.SetName("zookeeper.connection.active")
	m.data.SetDescription("Number of active clients connected to a ZooKeeper server.")
	m.data.SetUnit("{connections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperConnectionActive) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperConnectionActive) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperConnectionActive) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperConnectionActive(settings MetricSettings) metricZookeeperConnectionActive {
	m := metricZookeeperConnectionActive{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperDataTreeEphemeralNodeCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.data_tree.ephemeral_node.count metric with initial data.
func (m *metricZookeeperDataTreeEphemeralNodeCount) init() {
	m.data.SetName("zookeeper.data_tree.ephemeral_node.count")
	m.data.SetDescription("Number of ephemeral nodes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("{nodes}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperDataTreeEphemeralNodeCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperDataTreeEphemeralNodeCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperDataTreeEphemeralNodeCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperDataTreeEphemeralNodeCount(settings MetricSettings) metricZookeeperDataTreeEphemeralNodeCount {
	m := metricZookeeperDataTreeEphemeralNodeCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperDataTreeSize struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.data_tree.size metric with initial data.
func (m *metricZookeeperDataTreeSize) init() {
	m.data.SetName("zookeeper.data_tree.size")
	m.data.SetDescription("Size of data in bytes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperDataTreeSize) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperDataTreeSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperDataTreeSize) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperDataTreeSize(settings MetricSettings) metricZookeeperDataTreeSize {
	m := metricZookeeperDataTreeSize{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFileDescriptorLimit struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.file_descriptor.limit metric with initial data.
func (m *metricZookeeperFileDescriptorLimit) init() {
	m.data.SetName("zookeeper.file_descriptor.limit")
	m.data.SetDescription("Maximum number of file descriptors that a ZooKeeper server can open.")
	m.data.SetUnit("{file_descriptors}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperFileDescriptorLimit) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFileDescriptorLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFileDescriptorLimit) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFileDescriptorLimit(settings MetricSettings) metricZookeeperFileDescriptorLimit {
	m := metricZookeeperFileDescriptorLimit{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFileDescriptorOpen struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.file_descriptor.open metric with initial data.
func (m *metricZookeeperFileDescriptorOpen) init() {
	m.data.SetName("zookeeper.file_descriptor.open")
	m.data.SetDescription("Number of file descriptors that a ZooKeeper server has open.")
	m.data.SetUnit("{file_descriptors}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperFileDescriptorOpen) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFileDescriptorOpen) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFileDescriptorOpen) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFileDescriptorOpen(settings MetricSettings) metricZookeeperFileDescriptorOpen {
	m := metricZookeeperFileDescriptorOpen{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFollowerCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.follower.count metric with initial data.
func (m *metricZookeeperFollowerCount) init() {
	m.data.SetName("zookeeper.follower.count")
	m.data.SetDescription("The number of followers. Only exposed by the leader.")
	m.data.SetUnit("{followers}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricZookeeperFollowerCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, stateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.State, pdata.NewValueString(stateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFollowerCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFollowerCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFollowerCount(settings MetricSettings) metricZookeeperFollowerCount {
	m := metricZookeeperFollowerCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFsyncExceededThresholdCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.fsync.exceeded_threshold.count metric with initial data.
func (m *metricZookeeperFsyncExceededThresholdCount) init() {
	m.data.SetName("zookeeper.fsync.exceeded_threshold.count")
	m.data.SetDescription("Number of times fsync duration has exceeded warning threshold.")
	m.data.SetUnit("{events}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperFsyncExceededThresholdCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFsyncExceededThresholdCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFsyncExceededThresholdCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFsyncExceededThresholdCount(settings MetricSettings) metricZookeeperFsyncExceededThresholdCount {
	m := metricZookeeperFsyncExceededThresholdCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.avg metric with initial data.
func (m *metricZookeeperLatencyAvg) init() {
	m.data.SetName("zookeeper.latency.avg")
	m.data.SetDescription("Average time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyAvg(settings MetricSettings) metricZookeeperLatencyAvg {
	m := metricZookeeperLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.max metric with initial data.
func (m *metricZookeeperLatencyMax) init() {
	m.data.SetName("zookeeper.latency.max")
	m.data.SetDescription("Maximum time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperLatencyMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyMax(settings MetricSettings) metricZookeeperLatencyMax {
	m := metricZookeeperLatencyMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyMin struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.min metric with initial data.
func (m *metricZookeeperLatencyMin) init() {
	m.data.SetName("zookeeper.latency.min")
	m.data.SetDescription("Minimum time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperLatencyMin) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyMin) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyMin) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyMin(settings MetricSettings) metricZookeeperLatencyMin {
	m := metricZookeeperLatencyMin{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperPacketCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.packet.count metric with initial data.
func (m *metricZookeeperPacketCount) init() {
	m.data.SetName("zookeeper.packet.count")
	m.data.SetDescription("The number of ZooKeeper packets received or sent by a server.")
	m.data.SetUnit("{packets}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricZookeeperPacketCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperPacketCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperPacketCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperPacketCount(settings MetricSettings) metricZookeeperPacketCount {
	m := metricZookeeperPacketCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperRequestActive struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.request.active metric with initial data.
func (m *metricZookeeperRequestActive) init() {
	m.data.SetName("zookeeper.request.active")
	m.data.SetDescription("Number of currently executing requests.")
	m.data.SetUnit("{requests}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperRequestActive) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperRequestActive) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperRequestActive) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperRequestActive(settings MetricSettings) metricZookeeperRequestActive {
	m := metricZookeeperRequestActive{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperSyncPending struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.sync.pending metric with initial data.
func (m *metricZookeeperSyncPending) init() {
	m.data.SetName("zookeeper.sync.pending")
	m.data.SetDescription("The number of pending syncs from the followers. Only exposed by the leader.")
	m.data.SetUnit("{syncs}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperSyncPending) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperSyncPending) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperSyncPending) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperSyncPending(settings MetricSettings) metricZookeeperSyncPending {
	m := metricZookeeperSyncPending{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperWatchCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.watch.count metric with initial data.
func (m *metricZookeeperWatchCount) init() {
	m.data.SetName("zookeeper.watch.count")
	m.data.SetDescription("Number of watches placed on Z-Nodes on a ZooKeeper server.")
	m.data.SetUnit("{watches}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperWatchCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperWatchCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperWatchCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperWatchCount(settings MetricSettings) metricZookeeperWatchCount {
	m := metricZookeeperWatchCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperZnodeCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.znode.count metric with initial data.
func (m *metricZookeeperZnodeCount) init() {
	m.data.SetName("zookeeper.znode.count")
	m.data.SetDescription("Number of z-nodes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("{znodes}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperZnodeCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperZnodeCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperZnodeCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperZnodeCount(settings MetricSettings) metricZookeeperZnodeCount {
	m := metricZookeeperZnodeCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                  pdata.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                            int             // maximum observed number of metrics per resource.
	resourceCapacity                           int             // maximum observed number of resource attributes.
	metricsBuffer                              pdata.Metrics   // accumulates metrics data before emitting.
	metricZookeeperConnectionActive            metricZookeeperConnectionActive
	metricZookeeperDataTreeEphemeralNodeCount  metricZookeeperDataTreeEphemeralNodeCount
	metricZookeeperDataTreeSize                metricZookeeperDataTreeSize
	metricZookeeperFileDescriptorLimit         metricZookeeperFileDescriptorLimit
	metricZookeeperFileDescriptorOpen          metricZookeeperFileDescriptorOpen
	metricZookeeperFollowerCount               metricZookeeperFollowerCount
	metricZookeeperFsyncExceededThresholdCount metricZookeeperFsyncExceededThresholdCount
	metricZookeeperLatencyAvg                  metricZookeeperLatencyAvg
	metricZookeeperLatencyMax                  metricZookeeperLatencyMax
	metricZookeeperLatencyMin                  metricZookeeperLatencyMin
	metricZookeeperPacketCount                 metricZookeeperPacketCount
	metricZookeeperRequestActive               metricZookeeperRequestActive
	metricZookeeperSyncPending                 metricZookeeperSyncPending
	metricZookeeperWatchCount                  metricZookeeperWatchCount
	metricZookeeperZnodeCount                  metricZookeeperZnodeCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                       pdata.NewTimestampFromTime(time.Now()),
		metricsBuffer:                   pdata.NewMetrics(),
		metricZookeeperConnectionActive: newMetricZookeeperConnectionActive(settings.ZookeeperConnectionActive),
		metricZookeeperDataTreeEphemeralNodeCount:  newMetricZookeeperDataTreeEphemeralNodeCount(settings.ZookeeperDataTreeEphemeralNodeCount),
		metricZookeeperDataTreeSize:                newMetricZookeeperDataTreeSize(settings.ZookeeperDataTreeSize),
		metricZookeeperFileDescriptorLimit:         newMetricZookeeperFileDescriptorLimit(settings.ZookeeperFileDescriptorLimit),
		metricZookeeperFileDescriptorOpen:          newMetricZookeeperFileDescriptorOpen(settings.ZookeeperFileDescriptorOpen),
		metricZookeeperFollowerCount:               newMetricZookeeperFollowerCount(settings.ZookeeperFollowerCount),
		metricZookeeperFsyncExceededThresholdCount: newMetricZookeeperFsyncExceededThresholdCount(settings.ZookeeperFsyncExceededThresholdCount),
		metricZookeeperLatencyAvg:                  newMetricZookeeperLatencyAvg(settings.ZookeeperLatencyAvg),
		metricZookeeperLatencyMax:                  newMetricZookeeperLatencyMax(settings.ZookeeperLatencyMax),
		metricZookeeperLatencyMin:                  newMetricZookeeperLatencyMin(settings.ZookeeperLatencyMin),
		metricZookeeperPacketCount:                 newMetricZookeeperPacketCount(settings.ZookeeperPacketCount),
		metricZookeeperRequestActive:               newMetricZookeeperRequestActive(settings.ZookeeperRequestActive),
		metricZookeeperSyncPending:                 newMetricZookeeperSyncPending(settings.ZookeeperSyncPending),
		metricZookeeperWatchCount:                  newMetricZookeeperWatchCount(settings.ZookeeperWatchCount),
		metricZookeeperZnodeCount:                  newMetricZookeeperZnodeCount(settings.ZookeeperZnodeCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pdata.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceOption applies changes to provided resource.
type ResourceOption func(pdata.Resource)

// WithServerState sets provided value as "server.state" attribute for current resource.
func WithServerState(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("server.state", val)
	}
}

// WithZkVersion sets provided value as "zk.version" attribute for current resource.
func WithZkVersion(val string) ResourceOption {
	return func(r pdata.Resource) {
		r.Attributes().UpsertString("zk.version", val)
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead. Resource attributes should be provided as ResourceOption arguments.
func (mb *MetricsBuilder) EmitForResource(ro ...ResourceOption) {
	rm := pdata.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	for _, op := range ro {
		op(rm.Resource())
	}
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/zookeeperreceiver")
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricZookeeperConnectionActive.emit(ils.Metrics())
	mb.metricZookeeperDataTreeEphemeralNodeCount.emit(ils.Metrics())
	mb.metricZookeeperDataTreeSize.emit(ils.Metrics())
	mb.metricZookeeperFileDescriptorLimit.emit(ils.Metrics())
	mb.metricZookeeperFileDescriptorOpen.emit(ils.Metrics())
	mb.metricZookeeperFollowerCount.emit(ils.Metrics())
	mb.metricZookeeperFsyncExceededThresholdCount.emit(ils.Metrics())
	mb.metricZookeeperLatencyAvg.emit(ils.Metrics())
	mb.metricZookeeperLatencyMax.emit(ils.Metrics())
	mb.metricZookeeperLatencyMin.emit(ils.Metrics())
	mb.metricZookeeperPacketCount.emit(ils.Metrics())
	mb.metricZookeeperRequestActive.emit(ils.Metrics())
	mb.metricZookeeperSyncPending.emit(ils.Metrics())
	mb.metricZookeeperWatchCount.emit(ils.Metrics())
	mb.metricZookeeperZnodeCount.emit(ils.Metrics())
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(ro ...ResourceOption) pdata.Metrics {
	mb.EmitForResource(ro...)
	metrics := pdata.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordZookeeperConnectionActiveDataPoint adds a data point to zookeeper.connection.active metric.
func (mb *MetricsBuilder) RecordZookeeperConnectionActiveDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperConnectionActive.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperDataTreeEphemeralNodeCountDataPoint adds a data point to zookeeper.data_tree.ephemeral_node.count metric.
func (mb *MetricsBuilder) RecordZookeeperDataTreeEphemeralNodeCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperDataTreeEphemeralNodeCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperDataTreeSizeDataPoint adds a data point to zookeeper.data_tree.size metric.
func (mb *MetricsBuilder) RecordZookeeperDataTreeSizeDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperDataTreeSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperFileDescriptorLimitDataPoint adds a data point to zookeeper.file_descriptor.limit metric.
func (mb *MetricsBuilder) RecordZookeeperFileDescriptorLimitDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperFileDescriptorLimit.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperFileDescriptorOpenDataPoint adds a data point to zookeeper.file_descriptor.open metric.
func (mb *MetricsBuilder) RecordZookeeperFileDescriptorOpenDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperFileDescriptorOpen.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperFollowerCountDataPoint adds a data point to zookeeper.follower.count metric.
func (mb *MetricsBuilder) RecordZookeeperFollowerCountDataPoint(ts pdata.Timestamp, val int64, stateAttributeValue string) {
	mb.metricZookeeperFollowerCount.recordDataPoint(mb.startTime, ts, val, stateAttributeValue)
}

// RecordZookeeperFsyncExceededThresholdCountDataPoint adds a data point to zookeeper.fsync.exceeded_threshold.count metric.
func (mb *MetricsBuilder) RecordZookeeperFsyncExceededThresholdCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperFsyncExceededThresholdCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperLatencyAvgDataPoint adds a data point to zookeeper.latency.avg metric.
func (mb *MetricsBuilder) RecordZookeeperLatencyAvgDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperLatencyAvg.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperLatencyMaxDataPoint adds a data point to zookeeper.latency.max metric.
func (mb *MetricsBuilder) RecordZookeeperLatencyMaxDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperLatencyMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperLatencyMinDataPoint adds a data point to zookeeper.latency.min metric.
func (mb *MetricsBuilder) RecordZookeeperLatencyMinDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperLatencyMin.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperPacketCountDataPoint adds a data point to zookeeper.packet.count metric.
func (mb *MetricsBuilder) RecordZookeeperPacketCountDataPoint(ts pdata.Timestamp, val int64, directionAttributeValue string) {
	mb.metricZookeeperPacketCount.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordZookeeperRequestActiveDataPoint adds a data point to zookeeper.request.active metric.
func (mb *MetricsBuilder) RecordZookeeperRequestActiveDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperRequestActive.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperSyncPendingDataPoint adds a data point to zookeeper.sync.pending metric.
func (mb *MetricsBuilder) RecordZookeeperSyncPendingDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperSyncPending.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperWatchCountDataPoint adds a data point to zookeeper.watch.count metric.
func (mb *MetricsBuilder) RecordZookeeperWatchCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperWatchCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperZnodeCountDataPoint adds a data point to zookeeper.znode.count metric.
func (mb *MetricsBuilder) RecordZookeeperZnodeCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperZnodeCount.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Direction (State of a packet based on io direction.)
	Direction string
	// State (State of followers)
	State string
}{
	"direction",
	"state",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeDirection are the possible values that the attribute "direction" can have.
var AttributeDirection = struct {
	Received string
	Sent     string
}{
	"received",
	"sent",
}

// AttributeState are the possible values that the attribute "state" can have.
var AttributeState = struct {
	Synced   string
	Unsynced string
}{
	"synced",
	"unsynced",
}
